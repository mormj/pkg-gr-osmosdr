From dd6536757a3a2ce115491f12d730a592fbc07999 Mon Sep 17 00:00:00 2001
From: Heikki Hannikainen <hessu@hes.iki.fi>
Date: Tue, 24 Feb 2015 13:10:36 +0200
Subject: [PATCH 39/66] hackrf_sink_c: device enumeration

Signed-off-by: Heikki Hannikainen <hessu@hes.iki.fi>
---
 lib/hackrf/hackrf_sink_c.cc | 43 ++++++++++++++++++++++++++++---------------
 1 file changed, 28 insertions(+), 15 deletions(-)

diff --git a/lib/hackrf/hackrf_sink_c.cc b/lib/hackrf/hackrf_sink_c.cc
index a052093..2c8025b 100644
--- a/lib/hackrf/hackrf_sink_c.cc
+++ b/lib/hackrf/hackrf_sink_c.cc
@@ -474,30 +474,42 @@ std::vector<std::string> hackrf_sink_c::get_devices()
 {
   std::vector<std::string> devices;
   std::string label;
-#if 0
-  for (unsigned int i = 0; i < 1 /* TODO: missing libhackrf api */; i++) {
-    std::string args = "hackrf=" + boost::lexical_cast< std::string >( i );
+  
+  {
+    boost::mutex::scoped_lock lock( _usage_mutex );
+
+    if ( _usage == 0 )
+      hackrf_init(); /* call only once before the first open */
 
-    label.clear();
+    _usage++;
+  }
 
-    label = "HackRF Jawbreaker"; /* TODO: missing libhackrf api */
+#if 1
+  hackrf_device_list_t *list = hackrf_device_list();
+  
+  for (unsigned int i = 0; i < list->devicecount; i++) {
+    label = "HackRF ";
+    label += hackrf_usb_board_id_name( list->usb_board_ids[i] );
+    
+    std::string args;
+    if (list->serial_numbers[i]) {
+      std::string serial = boost::lexical_cast< std::string >( list->serial_numbers[i] );
+      if (serial.length() > 6)
+        serial = serial.substr(serial.length() - 6, 6);
+      args = "hackrf=" + serial;
+      label += " " + serial;
+    } else
+      args = "hackrf"; /* will pick the first one, serial number is required for choosing a specific one */
 
     boost::algorithm::trim(label);
 
     args += ",label='" + label + "'";
     devices.push_back( args );
   }
+  
+  hackrf_device_list_free(list);
 #else
 
-  {
-    boost::mutex::scoped_lock lock( _usage_mutex );
-
-    if ( _usage == 0 )
-      hackrf_init(); /* call only once before the first open */
-
-    _usage++;
-  }
-
   int ret;
   hackrf_device *dev = NULL;
   ret = hackrf_open(&dev);
@@ -520,6 +532,8 @@ std::vector<std::string> hackrf_sink_c::get_devices()
     ret = hackrf_close(dev);
   }
 
+#endif
+
   {
     boost::mutex::scoped_lock lock( _usage_mutex );
 
@@ -529,7 +543,6 @@ std::vector<std::string> hackrf_sink_c::get_devices()
       hackrf_exit(); /* call only once after last close */
   }
 
-#endif
   return devices;
 }
 
-- 
2.1.4

