From ea6b356cfda8a90fa6d727fcc13aae60547962a2 Mon Sep 17 00:00:00 2001
From: Dimitri Stolnikov <horiz0n@gmx.net>
Date: Wed, 14 Jun 2017 20:42:59 +0200
Subject: [PATCH 097/131] Remove workaround for gnuradio bug #528 as it has
 been fixed in 3.7.9.1

---
 CMakeLists.txt     |  2 +-
 lib/sink_impl.cc   | 43 +++----------------------------------------
 lib/source_impl.cc | 42 +++---------------------------------------
 3 files changed, 7 insertions(+), 80 deletions(-)

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 296456d..af21291 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -150,7 +150,7 @@ set(GRC_BLOCKS_DIR      ${GR_PKG_DATA_DIR}/grc/blocks)
 # Find build dependencies
 ########################################################################
 set(GR_REQUIRED_COMPONENTS RUNTIME PMT BLOCKS)
-set(MIN_GR_VERSION "3.7.8")
+set(MIN_GR_VERSION "3.7.10")
 find_package(Gnuradio REQUIRED)
 if("${Gnuradio_VERSION}" VERSION_LESS MIN_GR_VERSION)
     MESSAGE(FATAL_ERROR "GnuRadio version required: >=\"" ${MIN_GR_VERSION} "\" found: \"" ${Gnuradio_VERSION} "\"")
diff --git a/lib/sink_impl.cc b/lib/sink_impl.cc
index 285638b..877b31f 100644
--- a/lib/sink_impl.cc
+++ b/lib/sink_impl.cc
@@ -29,8 +29,6 @@
 
 #include <gnuradio/io_signature.h>
 #include <gnuradio/constants.h>
-#include <gnuradio/blocks/throttle.h>
-#include <gnuradio/blocks/null_sink.h>
 
 #ifdef ENABLE_UHD
 #include "uhd_sink_c.h"
@@ -57,10 +55,6 @@
 #include "arg_helpers.h"
 #include "sink_impl.h"
 
-/* This avoids throws in ctor of gr::hier_block2, as gnuradio is unable to deal
- with this behavior in a clean way. The GR maintainer Rondeau has been informed. */
-#define WORKAROUND_GR_HIER_BLOCK2_BUG
-
 /*
  * Create a new instance of sink_impl and return
  * a boost shared_ptr.  This is effectively the public constructor.
@@ -115,7 +109,7 @@ sink_impl::sink_impl( const std::string &args )
   std::cerr << "built-in sink types: ";
   BOOST_FOREACH(std::string dev_type, dev_types)
     std::cerr << dev_type << " ";
-  std::cerr << std::endl << std::flush;
+  std::cerr << std::endl;
 
   BOOST_FOREACH(std::string arg, arg_list) {
     dict_t dict = params_to_dict(arg);
@@ -126,9 +120,7 @@ sink_impl::sink_impl( const std::string &args )
       }
     }
   }
-#ifdef WORKAROUND_GR_HIER_BLOCK2_BUG
-  try {
-#endif
+
   if ( ! device_specified ) {
     std::vector< std::string > dev_list;
 #ifdef ENABLE_UHD
@@ -167,7 +159,7 @@ sink_impl::sink_impl( const std::string &args )
     if ( dev_list.size() )
       arg_list.push_back( dev_list.front() );
     else
-      throw std::runtime_error("No supported devices found to pick from.");
+      throw std::runtime_error("No supported devices found (check the connection and/or udev rules).");
   }
 
   BOOST_FOREACH(std::string arg, arg_list) {
@@ -237,35 +229,6 @@ sink_impl::sink_impl( const std::string &args )
 
   if (!_devs.size())
     throw std::runtime_error("No devices specified via device arguments.");
-#ifdef WORKAROUND_GR_HIER_BLOCK2_BUG
-  } catch ( std::exception &ex ) {
-    std::cerr << std::endl << "FATAL: " << ex.what() << std::endl << std::endl;
-
-    size_t missing_chans = 0;
-    if ( input_signature()->max_streams() > 0 )
-      missing_chans = input_signature()->max_streams() - channel;
-
-    std::cerr << "Trying to fill up " << missing_chans
-              << " missing channel(s) with null sink(s).\n"
-              << "This is being done to prevent the application from crashing\n"
-              << "due to gnuradio bug #528.\n"
-              << std::endl;
-
-    for (size_t i = 0; i < missing_chans; i++) {
-      /* we try to prevent the whole application from crashing by faking
-       * the missing hardware (channels) with a null sink */
-
-      gr::blocks::null_sink::sptr null_sink = \
-          gr::blocks::null_sink::make( sizeof(gr_complex) );
-
-      gr::blocks::throttle::sptr throttle = \
-          gr::blocks::throttle::make( sizeof(gr_complex), 1e5 );
-
-      connect(self(), channel++, throttle, 0);
-      connect(throttle, 0, null_sink, 0);
-    }
-  }
-#endif
 }
 
 size_t sink_impl::get_num_channels()
diff --git a/lib/source_impl.cc b/lib/source_impl.cc
index a28f314..a8a3cec 100644
--- a/lib/source_impl.cc
+++ b/lib/source_impl.cc
@@ -92,14 +92,9 @@
 #include <freesrp_source_c.h>
 #endif
 
-
 #include "arg_helpers.h"
 #include "source_impl.h"
 
-/* This avoids throws in ctor of gr::hier_block2, as gnuradio is unable to deal
- with this behavior in a clean way. The GR maintainer Rondeau has been informed. */
-#define WORKAROUND_GR_HIER_BLOCK2_BUG
-
 /*
  * Create a new instance of source_impl and return
  * a boost shared_ptr.  This is effectively the public constructor.
@@ -177,7 +172,7 @@ source_impl::source_impl( const std::string &args )
   std::cerr << "built-in source types: ";
   BOOST_FOREACH(std::string dev_type, dev_types)
     std::cerr << dev_type << " ";
-  std::cerr << std::endl << std::flush;
+  std::cerr << std::endl;
 
 #ifdef ENABLE_RFSPACE
   dev_types.push_back("sdr-iq"); /* additional aliases for rfspace backend */
@@ -195,9 +190,7 @@ source_impl::source_impl( const std::string &args )
       }
     }
   }
-#ifdef WORKAROUND_GR_HIER_BLOCK2_BUG
-  try {
-#endif
+
   if ( ! device_specified ) {
     std::vector< std::string > dev_list;
 #ifdef ENABLE_OSMOSDR
@@ -260,7 +253,7 @@ source_impl::source_impl( const std::string &args )
     if ( dev_list.size() )
       arg_list.push_back( dev_list.front() );
     else
-      throw std::runtime_error("No supported devices found to pick from.");
+      throw std::runtime_error("No supported devices found (check the connection and/or udev rules).");
   }
 
   BOOST_FOREACH(std::string arg, arg_list) {
@@ -410,35 +403,6 @@ source_impl::source_impl( const std::string &args )
 
   if (!_devs.size())
     throw std::runtime_error("No devices specified via device arguments.");
-#ifdef WORKAROUND_GR_HIER_BLOCK2_BUG
-  } catch ( std::exception &ex ) {
-    std::cerr << std::endl << "FATAL: " << ex.what() << std::endl << std::endl;
-
-    /* we try to prevent the whole application from crashing by faking
-     * the missing hardware (channels) with null sourc(e) */
-
-    gr::blocks::null_source::sptr null_source = \
-        gr::blocks::null_source::make( sizeof(gr_complex) );
-
-    gr::blocks::throttle::sptr throttle = \
-        gr::blocks::throttle::make( sizeof(gr_complex), 1e5 );
-
-    connect(null_source, 0, throttle, 0);
-
-    size_t missing_chans = 0;
-    if ( output_signature()->max_streams() > 0 )
-      missing_chans = output_signature()->max_streams() - channel;
-
-    std::cerr << "Trying to fill up " << missing_chans
-              << " missing channel(s) with null source(s).\n"
-              << "This is being done to prevent the application from crashing\n"
-              << "due to gnuradio bug #528.\n"
-              << std::endl;
-
-    for (size_t i = 0; i < missing_chans; i++)
-      connect(throttle, 0, self(), channel++);
-  }
-#endif
 }
 
 size_t source_impl::get_num_channels()
-- 
2.20.1

