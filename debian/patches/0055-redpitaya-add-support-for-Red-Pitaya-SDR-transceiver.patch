From 3582ba17e0d7a5237c6393a1c5849533692018f7 Mon Sep 17 00:00:00 2001
From: Pavel Demin <pavel.demin@uclouvain.be>
Date: Thu, 17 Dec 2015 21:12:45 +0100
Subject: [PATCH 55/66] redpitaya: add support for Red Pitaya SDR transceiver

This patch adds two gr-osmosdr blocks that can be used with the SDR transceiver
application available from the Red Pitaya application marketplace:

http://bazaar.redpitaya.com

These new source and sink blocks are based on the file block with some pieces
borrowed from the rtl_tcp block.

More details about Red Pitaya SDR transceiver can be found at:

http://pavel-demin.github.io/red-pitaya-notes/sdr-transceiver

Usage example:

osmocom_fft -a "redpitaya=192.168.1.100:1001"

Signed-off-by: Pavel Demin <pavel.demin@uclouvain.be>
---
 AUTHORS                             |   1 +
 lib/CMakeLists.txt                  |   8 +
 lib/config.h.in                     |   1 +
 lib/redpitaya/CMakeLists.txt        |  38 +++++
 lib/redpitaya/redpitaya_common.cc   |  52 +++++++
 lib/redpitaya/redpitaya_common.h    |  26 ++++
 lib/redpitaya/redpitaya_sink_c.cc   | 287 ++++++++++++++++++++++++++++++++++++
 lib/redpitaya/redpitaya_sink_c.h    |  81 ++++++++++
 lib/redpitaya/redpitaya_source_c.cc | 281 +++++++++++++++++++++++++++++++++++
 lib/redpitaya/redpitaya_source_c.h  |  81 ++++++++++
 lib/sink_impl.cc                    |  18 +++
 lib/source_impl.cc                  |  18 +++
 12 files changed, 892 insertions(+)
 create mode 100644 lib/redpitaya/CMakeLists.txt
 create mode 100644 lib/redpitaya/redpitaya_common.cc
 create mode 100644 lib/redpitaya/redpitaya_common.h
 create mode 100644 lib/redpitaya/redpitaya_sink_c.cc
 create mode 100644 lib/redpitaya/redpitaya_sink_c.h
 create mode 100644 lib/redpitaya/redpitaya_source_c.cc
 create mode 100644 lib/redpitaya/redpitaya_source_c.h

diff --git a/AUTHORS b/AUTHORS
index 9d07412..bc7249f 100644
--- a/AUTHORS
+++ b/AUTHORS
@@ -4,3 +4,4 @@ Hoernchen <la@tfc-server.de>
 Nuand LLC folks
 Josh Blum
 SDRplay Ltd.
+Pavel Demin
diff --git a/lib/CMakeLists.txt b/lib/CMakeLists.txt
index ae4649c..4ebc3e8 100644
--- a/lib/CMakeLists.txt
+++ b/lib/CMakeLists.txt
@@ -233,6 +233,14 @@ GR_INCLUDE_SUBDIRECTORY(soapy)
 endif(ENABLE_SOAPY)
 
 ########################################################################
+# Setup Red Pitaya component
+########################################################################
+GR_REGISTER_COMPONENT("Red Pitaya support" ENABLE_REDPITAYA)
+if(ENABLE_REDPITAYA)
+GR_INCLUDE_SUBDIRECTORY(redpitaya)
+endif(ENABLE_REDPITAYA)
+
+########################################################################
 # Setup configuration file
 ########################################################################
 ADD_DEFINITIONS(-DHAVE_CONFIG_H=1)
diff --git a/lib/config.h.in b/lib/config.h.in
index 542b364..1e843a8 100644
--- a/lib/config.h.in
+++ b/lib/config.h.in
@@ -17,6 +17,7 @@
 #cmakedefine ENABLE_RFSPACE
 #cmakedefine ENABLE_AIRSPY
 #cmakedefine ENABLE_SOAPY
+#cmakedefine ENABLE_REDPITAYA
 
 //provide NAN define for MSVC older than VC12
 #if defined(_MSC_VER) && (_MSC_VER < 1800)
diff --git a/lib/redpitaya/CMakeLists.txt b/lib/redpitaya/CMakeLists.txt
new file mode 100644
index 0000000..a14dc9e
--- /dev/null
+++ b/lib/redpitaya/CMakeLists.txt
@@ -0,0 +1,38 @@
+# Copyright 2012 Free Software Foundation, Inc.
+#
+# This file is part of GNU Radio
+#
+# GNU Radio is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3, or (at your option)
+# any later version.
+#
+# GNU Radio is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GNU Radio; see the file COPYING.  If not, write to
+# the Free Software Foundation, Inc., 51 Franklin Street,
+# Boston, MA 02110-1301, USA.
+
+########################################################################
+# This file included, use CMake directory variables
+########################################################################
+
+include_directories(
+    ${CMAKE_CURRENT_SOURCE_DIR}
+)
+
+set(redpitaya_srcs
+    ${CMAKE_CURRENT_SOURCE_DIR}/redpitaya_source_c.cc
+    ${CMAKE_CURRENT_SOURCE_DIR}/redpitaya_sink_c.cc
+    ${CMAKE_CURRENT_SOURCE_DIR}/redpitaya_common.cc
+)
+
+########################################################################
+# Append gnuradio-osmosdr library sources
+########################################################################
+list(APPEND gr_osmosdr_srcs ${redpitaya_srcs})
+#list(APPEND gr_osmosdr_libs ${GNURADIO_BLOCKS_LIBRARIES})
diff --git a/lib/redpitaya/redpitaya_common.cc b/lib/redpitaya/redpitaya_common.cc
new file mode 100644
index 0000000..7d91680
--- /dev/null
+++ b/lib/redpitaya/redpitaya_common.cc
@@ -0,0 +1,52 @@
+/* -*- c++ -*- */
+/*
+ * Copyright 2015 Pavel Demin
+ * Copyright 2012 Dimitri Stolnikov <horiz0n@gmx.net>
+ *
+ * GNU Radio is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3, or (at your option)
+ * any later version.
+ *
+ * GNU Radio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with GNU Radio; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include <fstream>
+#include <string>
+#include <sstream>
+#include <stdexcept>
+
+#ifdef _WIN32
+#include <winsock2.h>
+#include <ws2tcpip.h>
+#include <windows.h>
+#else
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#endif
+
+#include "redpitaya_common.h"
+
+void redpitaya_send_command( int socket, uint32_t command )
+{
+  ssize_t size;
+  std::stringstream message;
+
+  size = send( socket, &command, sizeof(command), MSG_NOSIGNAL );
+
+  if ( size != sizeof(command) )
+  {
+    message << "Sending command failed: " << std::hex << command;
+    throw std::runtime_error( message.str() );
+  }
+}
diff --git a/lib/redpitaya/redpitaya_common.h b/lib/redpitaya/redpitaya_common.h
new file mode 100644
index 0000000..a3c574a
--- /dev/null
+++ b/lib/redpitaya/redpitaya_common.h
@@ -0,0 +1,26 @@
+/* -*- c++ -*- */
+/*
+ * Copyright 2015 Pavel Demin
+ * Copyright 2015 Dimitri Stolnikov <horiz0n@gmx.net>
+ *
+ * GNU Radio is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3, or (at your option)
+ * any later version.
+ *
+ * GNU Radio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with GNU Radio; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street,
+ * Boston, MA 02110-1301, USA.
+ */
+#ifndef REDPITAYA_COMMON_H
+#define REDPITAYA_COMMON_H
+
+void redpitaya_send_command( int socket, uint32_t command );
+
+#endif // REDPITAYA_COMMON_H
diff --git a/lib/redpitaya/redpitaya_sink_c.cc b/lib/redpitaya/redpitaya_sink_c.cc
new file mode 100644
index 0000000..dd399af
--- /dev/null
+++ b/lib/redpitaya/redpitaya_sink_c.cc
@@ -0,0 +1,287 @@
+/* -*- c++ -*- */
+/*
+ * Copyright 2015 Pavel Demin
+ * Copyright 2012 Dimitri Stolnikov <horiz0n@gmx.net>
+ *
+ * GNU Radio is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3, or (at your option)
+ * any later version.
+ *
+ * GNU Radio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with GNU Radio; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include <fstream>
+#include <string>
+#include <sstream>
+#include <stdexcept>
+
+#ifdef _WIN32
+#include <winsock2.h>
+#include <ws2tcpip.h>
+#include <windows.h>
+#else
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#endif
+
+#include <boost/assign.hpp>
+#include <boost/format.hpp>
+#include <boost/algorithm/string.hpp>
+
+#include <gnuradio/io_signature.h>
+
+#include "redpitaya_common.h"
+#include "redpitaya_sink_c.h"
+
+#include "arg_helpers.h"
+
+using namespace boost::assign;
+
+redpitaya_sink_c_sptr make_redpitaya_sink_c(const std::string &args)
+{
+  return gnuradio::get_initial_sptr(new redpitaya_sink_c(args));
+}
+
+redpitaya_sink_c::redpitaya_sink_c(const std::string &args) :
+  gr::hier_block2("redpitaya_sink_c",
+                  gr::io_signature::make(1, 1, sizeof(gr_complex)),
+                  gr::io_signature::make(0, 0, 0))
+{
+  std::string host = "192.168.1.100";
+  std::stringstream message;
+  unsigned short ptt = 0, port = 1001;
+  struct sockaddr_in addr;
+  uint32_t command;
+
+#ifdef _WIN32
+  WSADATA wsaData;
+  WSAStartup( MAKEWORD(2, 2), &wsaData );
+#endif
+
+  _freq = 6.0e5;
+  _rate = 1.0e5;
+  _corr = 0.0;
+
+  dict_t dict = params_to_dict( args );
+
+  if ( dict.count( "redpitaya" ) )
+  {
+    std::vector< std::string > tokens;
+    boost::algorithm::split( tokens, dict["redpitaya"], boost::is_any_of( ":" ) );
+
+    if ( tokens[0].length() && ( tokens.size() == 1 || tokens.size() == 2 ) )
+      host = tokens[0];
+
+    if ( tokens.size() == 2 )
+      port = boost::lexical_cast< unsigned short >( tokens[1] );
+  }
+
+  if ( dict.count("ptt") )
+    ptt = boost::lexical_cast< unsigned short >( dict["ptt"] );
+
+  if ( !host.length() )
+    host = "192.168.1.100";
+
+  if ( 0 == port )
+    port = 1001;
+
+  for ( size_t i = 0; i < 2; ++i )
+  {
+    if ( ( _sockets[i] = socket( AF_INET, SOCK_STREAM, 0 ) ) < 0 )
+    {
+      throw std::runtime_error( "Could not create TCP socket." );
+    }
+
+    memset( &addr, 0, sizeof(addr) );
+    addr.sin_family = AF_INET;
+    addr.sin_addr.s_addr = inet_addr( host.c_str() );
+    addr.sin_port = htons( port );
+
+    if ( ::connect( _sockets[i], (struct sockaddr *)&addr, sizeof(addr) ) < 0 )
+    {
+      message << "Could not connect to " << host << ":" << port << ".";
+      throw std::runtime_error( message.str() );
+    }
+
+    command = i + 2;
+    redpitaya_send_command( _sockets[i], command );
+  }
+
+  command = ptt ? 2<<28 : 3<<28;
+  redpitaya_send_command( _sockets[0], command );
+
+  _sink = gr::blocks::file_descriptor_sink::make( sizeof(gr_complex), _sockets[1] );
+
+  connect( self(), 0, _sink, 0 );
+}
+
+redpitaya_sink_c::~redpitaya_sink_c()
+{
+  close( _sockets[1] );
+  close( _sockets[0] );
+
+#ifdef _WIN32
+  WSACleanup();
+#endif
+}
+
+std::string redpitaya_sink_c::name()
+{
+  return "Red Pitaya Sink";
+}
+
+std::vector<std::string> redpitaya_sink_c::get_devices( bool fake )
+{
+  std::vector<std::string> devices;
+
+  if ( fake )
+  {
+    std::string args = "redpitaya=192.168.1.100:1001";
+    args += ",label='Red Pitaya Transceiver Server'";
+    devices.push_back( args );
+  }
+
+  return devices;
+}
+
+size_t redpitaya_sink_c::get_num_channels( void )
+{
+  return 1;
+}
+
+osmosdr::meta_range_t redpitaya_sink_c::get_sample_rates( void )
+{
+  osmosdr::meta_range_t range;
+
+  range += osmosdr::range_t( 20000 );
+  range += osmosdr::range_t( 50000 );
+  range += osmosdr::range_t( 100000 );
+  range += osmosdr::range_t( 250000 );
+  range += osmosdr::range_t( 500000 );
+  range += osmosdr::range_t( 1250000 );
+
+  return range;
+}
+
+double redpitaya_sink_c::set_sample_rate( double rate )
+{
+  uint32_t command = 0;
+
+  if ( 20000 == rate ) command = 0;
+  else if ( 50000 == rate ) command = 1;
+  else if ( 100000 == rate ) command = 2;
+  else if ( 250000 == rate ) command = 3;
+  else if ( 500000 == rate ) command = 4;
+  else if ( 1250000 == rate ) command = 5;
+  else return get_sample_rate();
+
+  command |= 1<<28;
+  redpitaya_send_command( _sockets[0], command );
+
+  _rate = rate;
+
+  return get_sample_rate();
+}
+
+double redpitaya_sink_c::get_sample_rate( void )
+{
+  return _rate;
+}
+
+osmosdr::freq_range_t redpitaya_sink_c::get_freq_range( size_t chan )
+{
+  return osmosdr::freq_range_t( _rate / 2.0, 6.0e7 );
+}
+
+double redpitaya_sink_c::set_center_freq( double freq, size_t chan )
+{
+  uint32_t command = 0;
+
+  if ( freq < _rate / 2.0 || freq > 6.0e7 ) return get_center_freq( chan );
+
+  command = (uint32_t)floor( freq * (1.0 + _corr * 1.0e-6 ) + 0.5 );
+
+  redpitaya_send_command( _sockets[0], command );
+
+  _freq = freq;
+
+  return get_center_freq( chan );
+}
+
+double redpitaya_sink_c::get_center_freq( size_t chan )
+{
+  return _freq;
+}
+
+double redpitaya_sink_c::set_freq_corr( double ppm, size_t chan )
+{
+  _corr = ppm;
+
+  return get_freq_corr( chan );
+}
+
+double redpitaya_sink_c::get_freq_corr( size_t chan )
+{
+  return _corr;
+}
+
+std::vector<std::string> redpitaya_sink_c::get_gain_names( size_t chan )
+{
+  return std::vector< std::string >();
+}
+
+osmosdr::gain_range_t redpitaya_sink_c::get_gain_range( size_t chan )
+{
+  return osmosdr::gain_range_t();
+}
+
+osmosdr::gain_range_t redpitaya_sink_c::get_gain_range( const std::string & name, size_t chan )
+{
+  return get_gain_range( chan );
+}
+
+double redpitaya_sink_c::set_gain( double gain, size_t chan )
+{
+  return get_gain( chan );
+}
+
+double redpitaya_sink_c::set_gain( double gain, const std::string & name, size_t chan )
+{
+  return set_gain( chan );
+}
+
+double redpitaya_sink_c::get_gain( size_t chan )
+{
+  return 0;
+}
+
+double redpitaya_sink_c::get_gain( const std::string & name, size_t chan )
+{
+  return get_gain( chan );
+}
+
+std::vector< std::string > redpitaya_sink_c::get_antennas( size_t chan )
+{
+  return std::vector< std::string >();
+}
+
+std::string redpitaya_sink_c::set_antenna( const std::string & antenna, size_t chan )
+{
+  return get_antenna( chan );
+}
+
+std::string redpitaya_sink_c::get_antenna( size_t chan )
+{
+  return "TX";
+}
diff --git a/lib/redpitaya/redpitaya_sink_c.h b/lib/redpitaya/redpitaya_sink_c.h
new file mode 100644
index 0000000..ecdc670
--- /dev/null
+++ b/lib/redpitaya/redpitaya_sink_c.h
@@ -0,0 +1,81 @@
+/* -*- c++ -*- */
+/*
+ * Copyright 2015 Pavel Demin
+ * Copyright 2015 Dimitri Stolnikov <horiz0n@gmx.net>
+ *
+ * GNU Radio is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3, or (at your option)
+ * any later version.
+ *
+ * GNU Radio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with GNU Radio; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street,
+ * Boston, MA 02110-1301, USA.
+ */
+#ifndef REDPITAYA_SINK_C_H
+#define REDPITAYA_SINK_C_H
+
+#include <gnuradio/hier_block2.h>
+#include <gnuradio/blocks/file_descriptor_sink.h>
+
+#include "sink_iface.h"
+
+class redpitaya_sink_c;
+
+typedef boost::shared_ptr< redpitaya_sink_c > redpitaya_sink_c_sptr;
+
+redpitaya_sink_c_sptr make_redpitaya_sink_c( const std::string & args = "" );
+
+class redpitaya_sink_c :
+    public gr::hier_block2,
+    public sink_iface
+{
+private:
+  friend redpitaya_sink_c_sptr make_redpitaya_sink_c(const std::string &args);
+
+  redpitaya_sink_c(const std::string &args);
+
+public:
+  ~redpitaya_sink_c();
+
+  std::string name();
+
+  static std::vector< std::string > get_devices( bool fake = false );
+
+  size_t get_num_channels( void );
+
+  osmosdr::meta_range_t get_sample_rates( void );
+  double set_sample_rate( double rate );
+  double get_sample_rate( void );
+
+  osmosdr::freq_range_t get_freq_range( size_t chan = 0 );
+  double set_center_freq( double freq, size_t chan = 0 );
+  double get_center_freq( size_t chan = 0 );
+  double set_freq_corr( double ppm, size_t chan = 0 );
+  double get_freq_corr( size_t chan = 0 );
+
+  std::vector<std::string> get_gain_names( size_t chan = 0 );
+  osmosdr::gain_range_t get_gain_range( size_t chan = 0 );
+  osmosdr::gain_range_t get_gain_range( const std::string & name, size_t chan = 0 );
+  double set_gain( double gain, size_t chan = 0 );
+  double set_gain( double gain, const std::string & name, size_t chan = 0 );
+  double get_gain( size_t chan = 0 );
+  double get_gain( const std::string & name, size_t chan = 0 );
+
+  std::vector< std::string > get_antennas( size_t chan = 0 );
+  std::string set_antenna( const std::string & antenna, size_t chan = 0 );
+  std::string get_antenna( size_t chan = 0 );
+
+private:
+  gr::blocks::file_descriptor_sink::sptr _sink;
+  double _freq, _rate, _corr;
+  int _sockets[2];
+};
+
+#endif // REDPITAYA_SINK_C_H
diff --git a/lib/redpitaya/redpitaya_source_c.cc b/lib/redpitaya/redpitaya_source_c.cc
new file mode 100644
index 0000000..23ad977
--- /dev/null
+++ b/lib/redpitaya/redpitaya_source_c.cc
@@ -0,0 +1,281 @@
+/* -*- c++ -*- */
+/*
+ * Copyright 2015 Pavel Demin
+ * Copyright 2012 Dimitri Stolnikov <horiz0n@gmx.net>
+ *
+ * GNU Radio is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3, or (at your option)
+ * any later version.
+ *
+ * GNU Radio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with GNU Radio; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include <fstream>
+#include <string>
+#include <sstream>
+#include <stdexcept>
+
+#ifdef _WIN32
+#include <winsock2.h>
+#include <ws2tcpip.h>
+#include <windows.h>
+#else
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#endif
+
+#include <boost/assign.hpp>
+#include <boost/format.hpp>
+#include <boost/algorithm/string.hpp>
+
+#include <gnuradio/io_signature.h>
+
+#include "redpitaya_common.h"
+#include "redpitaya_source_c.h"
+
+#include "arg_helpers.h"
+
+using namespace boost::assign;
+
+redpitaya_source_c_sptr make_redpitaya_source_c(const std::string &args)
+{
+  return gnuradio::get_initial_sptr(new redpitaya_source_c(args));
+}
+
+redpitaya_source_c::redpitaya_source_c(const std::string &args) :
+  gr::hier_block2("redpitaya_source_c",
+                  gr::io_signature::make(0, 0, 0),
+                  gr::io_signature::make(1, 1, sizeof(gr_complex)))
+{
+  std::string host = "192.168.1.100";
+  std::stringstream message;
+  unsigned short port = 1001;
+  struct sockaddr_in addr;
+  uint32_t command;
+
+#ifdef _WIN32
+  WSADATA wsaData;
+  WSAStartup( MAKEWORD(2, 2), &wsaData );
+#endif
+
+  _freq = 6.0e5;
+  _rate = 1.0e5;
+  _corr = 0.0;
+
+  dict_t dict = params_to_dict( args );
+
+  if ( dict.count( "redpitaya" ) )
+  {
+    std::vector< std::string > tokens;
+    boost::algorithm::split( tokens, dict["redpitaya"], boost::is_any_of( ":" ) );
+
+    if ( tokens[0].length() && ( tokens.size() == 1 || tokens.size() == 2 ) )
+      host = tokens[0];
+
+    if ( tokens.size() == 2 )
+      port = boost::lexical_cast< unsigned short >( tokens[1] );
+  }
+
+  if ( !host.length() )
+    host = "192.168.1.100";
+
+  if ( 0 == port )
+    port = 1001;
+
+  for ( size_t i = 0; i < 2; ++i )
+  {
+    if ( ( _sockets[i] = socket( AF_INET, SOCK_STREAM, 0 ) ) < 0 )
+    {
+      throw std::runtime_error( "Could not create TCP socket." );
+    }
+
+    memset( &addr, 0, sizeof(addr) );
+    addr.sin_family = AF_INET;
+    addr.sin_addr.s_addr = inet_addr( host.c_str() );
+    addr.sin_port = htons( port );
+
+    if ( ::connect( _sockets[i], (struct sockaddr *)&addr, sizeof(addr) ) < 0 )
+    {
+      message << "Could not connect to " << host << ":" << port << ".";
+      throw std::runtime_error( message.str() );
+    }
+
+    command = i;
+    redpitaya_send_command( _sockets[i], command );
+  }
+
+  _source = gr::blocks::file_descriptor_source::make( sizeof(gr_complex), _sockets[1] );
+
+  connect( _source, 0, self(), 0 );
+}
+
+redpitaya_source_c::~redpitaya_source_c()
+{
+  close( _sockets[1] );
+  close( _sockets[0] );
+
+#ifdef _WIN32
+  WSACleanup();
+#endif
+}
+
+std::string redpitaya_source_c::name()
+{
+  return "Red Pitaya Source";
+}
+
+std::vector<std::string> redpitaya_source_c::get_devices( bool fake )
+{
+  std::vector<std::string> devices;
+
+  if ( fake )
+  {
+    std::string args = "redpitaya=192.168.1.100:1001";
+    args += ",label='Red Pitaya Transceiver Server'";
+    devices.push_back( args );
+  }
+
+  return devices;
+}
+
+size_t redpitaya_source_c::get_num_channels( void )
+{
+  return 1;
+}
+
+osmosdr::meta_range_t redpitaya_source_c::get_sample_rates( void )
+{
+  osmosdr::meta_range_t range;
+
+  range += osmosdr::range_t( 20000 );
+  range += osmosdr::range_t( 50000 );
+  range += osmosdr::range_t( 100000 );
+  range += osmosdr::range_t( 250000 );
+  range += osmosdr::range_t( 500000 );
+  range += osmosdr::range_t( 1250000 );
+
+  return range;
+}
+
+double redpitaya_source_c::set_sample_rate( double rate )
+{
+  uint32_t command = 0;
+
+  if ( 20000 == rate ) command = 0;
+  else if ( 50000 == rate ) command = 1;
+  else if ( 100000 == rate ) command = 2;
+  else if ( 250000 == rate ) command = 3;
+  else if ( 500000 == rate ) command = 4;
+  else if ( 1250000 == rate ) command = 5;
+  else return get_sample_rate();
+
+  command |= 1<<28;
+  redpitaya_send_command( _sockets[0], command );
+
+  _rate = rate;
+
+  return get_sample_rate();
+}
+
+double redpitaya_source_c::get_sample_rate( void )
+{
+  return _rate;
+}
+
+osmosdr::freq_range_t redpitaya_source_c::get_freq_range( size_t chan )
+{
+  return osmosdr::freq_range_t( _rate / 2.0, 6.0e7 );
+}
+
+double redpitaya_source_c::set_center_freq( double freq, size_t chan )
+{
+  uint32_t command = 0;
+
+  if ( freq < _rate / 2.0 || freq > 6.0e7 ) return get_center_freq( chan );
+
+  command = (uint32_t)floor( freq * (1.0 + _corr * 1.0e-6 ) + 0.5 );
+
+  redpitaya_send_command( _sockets[0], command );
+
+  _freq = freq;
+
+  return get_center_freq( chan );
+}
+
+double redpitaya_source_c::get_center_freq( size_t chan )
+{
+  return _freq;
+}
+
+double redpitaya_source_c::set_freq_corr( double ppm, size_t chan )
+{
+  _corr = ppm;
+
+  return get_freq_corr( chan );
+}
+
+double redpitaya_source_c::get_freq_corr( size_t chan )
+{
+  return _corr;
+}
+
+std::vector<std::string> redpitaya_source_c::get_gain_names( size_t chan )
+{
+  return std::vector< std::string >();
+}
+
+osmosdr::gain_range_t redpitaya_source_c::get_gain_range( size_t chan )
+{
+  return osmosdr::gain_range_t();
+}
+
+osmosdr::gain_range_t redpitaya_source_c::get_gain_range( const std::string & name, size_t chan )
+{
+  return get_gain_range( chan );
+}
+
+double redpitaya_source_c::set_gain( double gain, size_t chan )
+{
+  return get_gain( chan );
+}
+
+double redpitaya_source_c::set_gain( double gain, const std::string & name, size_t chan )
+{
+  return set_gain( chan );
+}
+
+double redpitaya_source_c::get_gain( size_t chan )
+{
+  return 0;
+}
+
+double redpitaya_source_c::get_gain( const std::string & name, size_t chan )
+{
+  return get_gain( chan );
+}
+
+std::vector< std::string > redpitaya_source_c::get_antennas( size_t chan )
+{
+  return std::vector< std::string >();
+}
+
+std::string redpitaya_source_c::set_antenna( const std::string & antenna, size_t chan )
+{
+  return get_antenna( chan );
+}
+
+std::string redpitaya_source_c::get_antenna( size_t chan )
+{
+  return "RX";
+}
diff --git a/lib/redpitaya/redpitaya_source_c.h b/lib/redpitaya/redpitaya_source_c.h
new file mode 100644
index 0000000..20a8f9f
--- /dev/null
+++ b/lib/redpitaya/redpitaya_source_c.h
@@ -0,0 +1,81 @@
+/* -*- c++ -*- */
+/*
+ * Copyright 2015 Pavel Demin
+ * Copyright 2012 Dimitri Stolnikov <horiz0n@gmx.net>
+ *
+ * GNU Radio is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3, or (at your option)
+ * any later version.
+ *
+ * GNU Radio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with GNU Radio; see the file COPYING.  If not, write to
+ * the Free Software Foundation, Inc., 51 Franklin Street,
+ * Boston, MA 02110-1301, USA.
+ */
+#ifndef REDPITAYA_SOURCE_C_H
+#define REDPITAYA_SOURCE_C_H
+
+#include <gnuradio/hier_block2.h>
+#include <gnuradio/blocks/file_descriptor_source.h>
+
+#include "source_iface.h"
+
+class redpitaya_source_c;
+
+typedef boost::shared_ptr< redpitaya_source_c > redpitaya_source_c_sptr;
+
+redpitaya_source_c_sptr make_redpitaya_source_c( const std::string & args = "" );
+
+class redpitaya_source_c :
+    public gr::hier_block2,
+    public source_iface
+{
+private:
+  friend redpitaya_source_c_sptr make_redpitaya_source_c(const std::string &args);
+
+  redpitaya_source_c(const std::string &args);
+
+public:
+  ~redpitaya_source_c();
+
+  std::string name();
+
+  static std::vector< std::string > get_devices( bool fake = false );
+
+  size_t get_num_channels( void );
+
+  osmosdr::meta_range_t get_sample_rates( void );
+  double set_sample_rate( double rate );
+  double get_sample_rate( void );
+
+  osmosdr::freq_range_t get_freq_range( size_t chan = 0 );
+  double set_center_freq( double freq, size_t chan = 0 );
+  double get_center_freq( size_t chan = 0 );
+  double set_freq_corr( double ppm, size_t chan = 0 );
+  double get_freq_corr( size_t chan = 0 );
+
+  std::vector<std::string> get_gain_names( size_t chan = 0 );
+  osmosdr::gain_range_t get_gain_range( size_t chan = 0 );
+  osmosdr::gain_range_t get_gain_range( const std::string & name, size_t chan = 0 );
+  double set_gain( double gain, size_t chan = 0 );
+  double set_gain( double gain, const std::string & name, size_t chan = 0 );
+  double get_gain( size_t chan = 0 );
+  double get_gain( const std::string & name, size_t chan = 0 );
+
+  std::vector< std::string > get_antennas( size_t chan = 0 );
+  std::string set_antenna( const std::string & antenna, size_t chan = 0 );
+  std::string get_antenna( size_t chan = 0 );
+
+private:
+  gr::blocks::file_descriptor_source::sptr _source;
+  double _freq, _rate, _corr;
+  int _sockets[2];
+};
+
+#endif // REDPITAYA_SOURCE_C_H
diff --git a/lib/sink_impl.cc b/lib/sink_impl.cc
index 6f01522..146f1a9 100644
--- a/lib/sink_impl.cc
+++ b/lib/sink_impl.cc
@@ -46,6 +46,10 @@
 #include <soapy_sink_c.h>
 #endif
 
+#ifdef ENABLE_REDPITAYA
+#include <redpitaya_sink_c.h>
+#endif
+
 #include "arg_helpers.h"
 #include "sink_impl.h"
 
@@ -91,6 +95,9 @@ sink_impl::sink_impl( const std::string &args )
 #ifdef ENABLE_SOAPY
   dev_types.push_back("soapy");
 #endif
+#ifdef ENABLE_REDPITAYA
+  dev_types.push_back("redpitaya");
+#endif
   std::cerr << "gr-osmosdr "
             << GR_OSMOSDR_VERSION << " (" << GR_OSMOSDR_LIBVER << ") "
             << "gnuradio " << gr::version() << std::endl;
@@ -129,6 +136,10 @@ sink_impl::sink_impl( const std::string &args )
     BOOST_FOREACH( std::string dev, soapy_sink_c::get_devices() )
       dev_list.push_back( dev );
 #endif
+#ifdef ENABLE_REDPITAYA
+    BOOST_FOREACH( std::string dev, redpitaya_sink_c::get_devices() )
+      dev_list.push_back( dev );
+#endif
 
 //    std::cerr << std::endl;
 //    BOOST_FOREACH( std::string dev, dev_list )
@@ -177,6 +188,13 @@ sink_impl::sink_impl( const std::string &args )
     }
 #endif
 
+#ifdef ENABLE_REDPITAYA
+    if ( dict.count("redpitaya") ) {
+      redpitaya_sink_c_sptr sink = make_redpitaya_sink_c( arg );
+      block = sink; iface = sink.get();
+    }
+#endif
+
     if ( iface != NULL && long(block.get()) != 0 ) {
       _devs.push_back( iface );
 
diff --git a/lib/source_impl.cc b/lib/source_impl.cc
index 9b81dde..3aa17f9 100644
--- a/lib/source_impl.cc
+++ b/lib/source_impl.cc
@@ -84,6 +84,10 @@
 #include <soapy_source_c.h>
 #endif
 
+#ifdef ENABLE_REDPITAYA
+#include <redpitaya_source_c.h>
+#endif
+
 #include "arg_helpers.h"
 #include "source_impl.h"
 
@@ -156,6 +160,9 @@ source_impl::source_impl( const std::string &args )
 #ifdef ENABLE_SOAPY
   dev_types.push_back("soapy");
 #endif
+#ifdef ENABLE_REDPITAYA
+  dev_types.push_back("redpitaya");
+#endif
   std::cerr << "gr-osmosdr "
             << GR_OSMOSDR_VERSION << " (" << GR_OSMOSDR_LIBVER << ") "
             << "gnuradio " << gr::version() << std::endl;
@@ -229,6 +236,10 @@ source_impl::source_impl( const std::string &args )
     BOOST_FOREACH( std::string dev, soapy_source_c::get_devices() )
       dev_list.push_back( dev );
 #endif
+#ifdef ENABLE_REDPITAYA
+    BOOST_FOREACH( std::string dev, redpitaya_source_c::get_devices() )
+      dev_list.push_back( dev );
+#endif
 
 //    std::cerr << std::endl;
 //    BOOST_FOREACH( std::string dev, dev_list )
@@ -346,6 +357,13 @@ source_impl::source_impl( const std::string &args )
     }
 #endif
 
+#ifdef ENABLE_REDPITAYA
+    if ( dict.count("redpitaya") ) {
+      redpitaya_source_c_sptr src = make_redpitaya_source_c( arg );
+      block = src; iface = src.get();
+    }
+#endif
+
     if ( iface != NULL && long(block.get()) != 0 ) {
       _devs.push_back( iface );
 
-- 
2.1.4

