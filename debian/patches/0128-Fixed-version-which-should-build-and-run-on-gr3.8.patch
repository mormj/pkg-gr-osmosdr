From ba70b235d56bd8770d708e5953b295aed8ab028f Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Mickey=20V=C3=A4nsk=C3=A4?= <mvaenskae@gmail.com>
Date: Sun, 7 Apr 2019 19:44:33 +0200
Subject: [PATCH 128/131] Fixed version which should build and run on gr3.8.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Mickey Vänskä <mvaenskae@gmail.com>
---
 CMakeLists.txt                            |  44 +-
 README                                    |   2 +-
 apps/CMakeLists.txt                       |   5 +-
 apps/osmocom_siggen_base.py               |  86 +--
 cmake/Modules/FindGnuradioFCD.cmake       |  34 +
 cmake/Modules/FindGnuradioFCDPP.cmake     |  34 +
 cmake/Modules/FindGnuradioIQBalance.cmake |  29 +
 cmake/Modules/FindGnuradioUHD.cmake       |  34 +
 cmake/Modules/FindUHD.cmake               |  28 +
 cmake/Modules/GrComponent.cmake           | 115 ++++
 cmake/Modules/GrMiscUtils.cmake           | 519 +++++++++++++++
 cmake/Modules/GrPlatform.cmake            |  54 ++
 cmake/Modules/GrPython.cmake              | 242 +++++++
 cmake/Modules/GrTest.cmake                | 143 ++++
 cmake/Modules/GrVersion.cmake             |  82 +++
 grc/gen_osmosdr_blocks.py                 |   6 +-
 include/osmosdr/CMakeLists.txt            |  12 +-
 include/osmosdr/api.h                     |   3 +-
 include/osmosdr/sink.h                    | 689 ++++++++++----------
 include/osmosdr/source.h                  | 755 +++++++++++-----------
 lib/CMakeLists.txt                        |  15 +-
 python/CMakeLists.txt                     |   3 +-
 python/__init__.py                        |   7 +-
 swig/CMakeLists.txt                       |  14 +-
 swig/osmosdr_swig.i                       |  70 +-
 25 files changed, 2201 insertions(+), 824 deletions(-)
 create mode 100644 cmake/Modules/FindGnuradioFCD.cmake
 create mode 100644 cmake/Modules/FindGnuradioFCDPP.cmake
 create mode 100644 cmake/Modules/FindGnuradioIQBalance.cmake
 create mode 100644 cmake/Modules/FindGnuradioUHD.cmake
 create mode 100644 cmake/Modules/FindUHD.cmake
 create mode 100644 cmake/Modules/GrComponent.cmake
 create mode 100644 cmake/Modules/GrMiscUtils.cmake
 create mode 100644 cmake/Modules/GrPlatform.cmake
 create mode 100644 cmake/Modules/GrPython.cmake
 create mode 100644 cmake/Modules/GrTest.cmake
 create mode 100644 cmake/Modules/GrVersion.cmake

diff --git a/CMakeLists.txt b/CMakeLists.txt
index e932d70..f836233 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -1,7 +1,6 @@
-# Copyright 2011,2012,2014,2016,2018 Free Software Foundation, Inc.
+# Copyright 2012 Free Software Foundation, Inc.
 #
-# This file was generated by gr_modtool, a tool from the GNU Radio framework
-# This file is a part of gr-osmosdr
+# This file is part of GNU Radio
 #
 # GNU Radio is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
@@ -47,6 +46,8 @@ set(CMAKE_BUILD_TYPE ${CMAKE_BUILD_TYPE} CACHE STRING "")
 #make sure our local CMake Modules path comes first
 list(INSERT CMAKE_MODULE_PATH 0 ${CMAKE_SOURCE_DIR}/cmake/Modules)
 
+set(ENABLE_NONFREE FALSE CACHE BOOL "Enable or disable nonfree components.")
+
 # Set the version information here
 set(VERSION_INFO_MAJOR_VERSION 0)
 set(VERSION_INFO_API_COMPAT    1)
@@ -107,17 +108,12 @@ ELSEIF(MSVC)
     ENDIF()
 ENDIF()
 
-#if((CMAKE_CXX_COMPILER_ID MATCHES "Clang" OR
-#    CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
-#    AND NOT WIN32)
-#    #http://gcc.gnu.org/wiki/Visibility
-#    add_definitions(-fvisibility=hidden)
-#endif()
 
 ########################################################################
 # Install directories
 ########################################################################
-find_package(Gnuradio "3.8" REQUIRED) # Side effect of MODULE_PATH getting prepended with system components
+find_package(Gnuradio REQUIRED) # Side effect of MODULE_PATH getting prepended with system components
+list(REVERSE CMAKE_MODULE_PATH)
 set(MIN_GR_VERSION "3.8")
 if("${Gnuradio_VERSION}" VERSION_LESS MIN_GR_VERSION)
     MESSAGE(FATAL_ERROR "GnuRadio version required: >=\"" ${MIN_GR_VERSION} "\" found: \"" ${Gnuradio_VERSION} "\"")
@@ -130,18 +126,19 @@ if(NOT CMAKE_MODULES_DIR)
     set(CMAKE_MODULES_DIR lib${LIB_SUFFIX}/cmake)
 endif(NOT CMAKE_MODULES_DIR)
 
-#set(GR_RUNTIME_DIR      bin)
+set(GR_CMAKE_DIR        ${CMAKE_MODULES_DIR}/osmosdr)
+set(GR_RUNTIME_DIR      bin)
 set(GR_LIBRARY_DIR      lib${LIB_SUFFIX})
-#set(GR_INCLUDE_DIR      include)
-#set(GR_DATA_DIR         share)
+set(GR_INCLUDE_DIR      include)
+set(GR_DATA_DIR         share)
 set(GR_PKG_DATA_DIR     ${GR_DATA_DIR}/${CMAKE_PROJECT_NAME})
-#set(GR_DOC_DIR          ${GR_DATA_DIR}/doc)
+set(GR_DOC_DIR          ${GR_DATA_DIR}/doc)
 if (NOT GR_PKG_DOC_DIR)
     set(GR_PKG_DOC_DIR      ${GR_DOC_DIR}/${CMAKE_PROJECT_NAME})
 endif()
-#set(GR_CONF_DIR         etc)
+set(GR_CONF_DIR         etc)
 set(GR_PKG_CONF_DIR     ${GR_CONF_DIR}/${CMAKE_PROJECT_NAME}/conf.d)
-#set(GR_LIBEXEC_DIR      libexec)
+set(GR_LIBEXEC_DIR      libexec)
 set(GR_PKG_LIBEXEC_DIR  ${GR_LIBEXEC_DIR}/${CMAKE_PROJECT_NAME})
 set(GRC_BLOCKS_DIR      ${GR_PKG_DATA_DIR}/grc/blocks)
 
@@ -166,11 +163,11 @@ if(APPLE)
 endif(APPLE)
 
 ########################################################################
-# Find gnuradio build dependencies
+# Find build dependencies
 ########################################################################
 set(GR_REQUIRED_COMPONENTS RUNTIME PMT BLOCKS)
 
-find_package(gnuradio-blocks PATHS ${GR_PREFIX}/lib/cmake/gnuradio/)
+#[[find_package(gnuradio-blocks PATHS ${GR_PREFIX}/lib/cmake/gnuradio/)
 message(STATUS "Found Block Block: ${gnuradio-blocks_FOUND}")
 
 find_package(gnuradio-pmt PATHS ${GR_PREFIX}/lib/cmake/gnuradio/)
@@ -198,9 +195,11 @@ message (STATUS "Found UHD Block: ${gnuradio-uhd_FOUND}")
 message(STATUS " Searching for Volk...")
 #find_package(Gnuradio COMPONENTS Volk REQUIRED)
 find_package(volk PATHS ${GR_PREFIX}/lib/cmake/volk)
-message (STATUS "Found Volk: ${volk_FOUND}")
+message (STATUS "Found Volk: ${volk_FOUND}") ]]#
 
-# Hardware Drivers from here on out -- These may fail as the user hasn't installed them
+find_package(GnuradioIQBalance)
+find_package(UHD)
+find_package(GnuradioUHD)
 find_package(LibOsmoSDR)
 find_package(LibRTLSDR)
 find_package(LibMiriSDR)
@@ -209,11 +208,10 @@ if(ENABLE_NONFREE)
 endif(ENABLE_NONFREE)
 find_package(LibHackRF)
 find_package(LibAIRSPY)
+find_package(Volk)
 find_package(LibbladeRF)
 find_package(SoapySDR NO_MODULE)
 find_package(LibFreeSRP)
-
-# Documentation System
 find_package(Doxygen)
 
 #get_cmake_property(_variableNames VARIABLES)
@@ -267,7 +265,7 @@ add_custom_target(uninstall
 ########################################################################
 # Enable python component
 ########################################################################
-find_package(PythonLibs 2)
+find_package(PythonLibs)
 find_package(SWIG)
 
 if(SWIG_FOUND)
diff --git a/README b/README
index 193656f..4d8363b 100644
--- a/README
+++ b/README
@@ -20,7 +20,7 @@ as well supports:
 By using the OsmoSDR block you can take advantage of a common software api in
 your application(s) independent of the underlying radio hardware.
 
-Ftor installation and usage guidelines please read the documentation available
+For installation and usage guidelines please read the documentation available
 at http://sdr.osmocom.org/trac/wiki/GrOsmoSDR
 
 For the impatient :) a short excerpt:
diff --git a/apps/CMakeLists.txt b/apps/CMakeLists.txt
index ee966bb..9c30a4b 100644
--- a/apps/CMakeLists.txt
+++ b/apps/CMakeLists.txt
@@ -1,7 +1,6 @@
 # Copyright 2011 Free Software Foundation, Inc.
 #
-# This file was generated by gr_modtool, a tool from the GNU Radio framework
-# This file is a part of gr-osmosdr
+# This file is part of GNU Radio
 #
 # GNU Radio is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
@@ -21,7 +20,7 @@
 include(GrPython)
 
 GR_PYTHON_INSTALL(
-    PROGRAMS
+    FILES
     osmocom_siggen_base.py
     DESTINATION ${GR_PYTHON_DIR}/osmosdr
 )
diff --git a/apps/osmocom_siggen_base.py b/apps/osmocom_siggen_base.py
index b6e9a0c..f07f3f6 100644
--- a/apps/osmocom_siggen_base.py
+++ b/apps/osmocom_siggen_base.py
@@ -109,9 +109,9 @@ class gsm_source_c(gr.hier_block2):
             [0,0,0],
         ]
         burst = sum(chunks,[])
-        burst = sum(map(list, zip(burst, (1,) * len(burst))), [])
+        burst = sum(list(map(list, list(zip(burst, (1,) * len(burst))))), [])
         burst += [1,0] * (l-148)
-        return map(int, burst)
+        return list(map(int, burst))
 
     def gen_gsm_frame(self):
         return \
@@ -186,7 +186,7 @@ class top_block(gr.top_block, pubsub):
         try:
             self._sink.get_sample_rates().start()
         except RuntimeError:
-            print "Sink has no sample rates (wrong device arguments?)."
+            print("Sink has no sample rates (wrong device arguments?).")
             sys.exit(1)
 
         # Set the clock source:
@@ -202,60 +202,60 @@ class top_block(gr.top_block, pubsub):
         if(options.gain):
             gain = self._sink.set_gain(options.gain)
             if self._verbose:
-                print "Set gain to:", gain
+                print("Set gain to:", gain)
 
         if self._verbose:
             gain_names = self._sink.get_gain_names()
             for name in gain_names:
                 range = self._sink.get_gain_range(name)
-                print "%s gain range: start %d stop %d step %d" % (name, range.start(), range.stop(), range.step())
+                print("%s gain range: start %d stop %d step %d" % (name, range.start(), range.stop(), range.step()))
 
         if options.gains:
             for tuple in options.gains.split(","):
                 name, gain = tuple.split(":")
                 gain = int(gain)
-                print "Setting gain %s to %d." % (name, gain)
+                print("Setting gain %s to %d." % (name, gain))
                 self._sink.set_gain(gain, name)
 
         if self._verbose:
             rates = self._sink.get_sample_rates()
-            print 'Supported sample rates %d-%d step %d.' % (rates.start(), rates.stop(), rates.step())
+            print('Supported sample rates %d-%d step %d.' % (rates.start(), rates.stop(), rates.step()))
 
         # Set the antenna
         if self._verbose:
-            print "setting antenna..."
+            print("setting antenna...")
         if(options.antenna):
             ant = self._sink.set_antenna(options.antenna, 0)
             if self._verbose:
-                print "Set antenna to:", ant
+                print("Set antenna to:", ant)
         try:
             self.publish(FREQ_RANGE_KEY, self._sink.get_freq_range)
         except:
-            print "Couldn't publish %s" % FREQ_RANGE_KEY
+            print("Couldn't publish %s" % FREQ_RANGE_KEY)
 
         try:
             for name in self.get_gain_names():
                 self.publish(GAIN_RANGE_KEY(name), (lambda self=self,name=name: self._sink.get_gain_range(name)))
         except:
-            print "Couldn't publish %s" % FREQ_RANGE_KEY
+            print("Couldn't publish %s" % FREQ_RANGE_KEY)
 
         try:
             self.publish(BWIDTH_RANGE_KEY, self._sink.get_bandwidth_range)
         except:
             if self._verbose:
-                print "Couldn't publish %s" % BWIDTH_RANGE_KEY
+                print("Couldn't publish %s" % BWIDTH_RANGE_KEY)
 
         try:
             for name in self.get_gain_names():
                 self.publish(GAIN_KEY(name), (lambda self=self,name=name: self._sink.get_gain(name)))
         except:
             if self._verbose:
-                print "Couldn't publish GAIN_KEYs"
+                print("Couldn't publish GAIN_KEYs")
         try:
             self.publish(BWIDTH_KEY, self._sink.get_bandwidth)
         except:
             if self._verbose:
-                print "Couldn't publish %s" % BWIDTH_KEY
+                print("Couldn't publish %s" % BWIDTH_KEY)
 
     def get_gain_names(self):
         return self._sink.get_gain_names()
@@ -277,7 +277,7 @@ class top_block(gr.top_block, pubsub):
             return True # Waveform not yet set
 
         if self._verbose:
-            print "Set sample rate to:", sr
+            print("Set sample rate to:", sr)
 
         return True
 
@@ -286,27 +286,27 @@ class top_block(gr.top_block, pubsub):
             g = self[GAIN_RANGE_KEY(name)]
             gain = float(g.start()+g.stop())/2
             if self._verbose:
-                print "Using auto-calculated mid-point gain"
+                print("Using auto-calculated mid-point gain")
             self[GAIN_KEY(name)] = gain
             return
 
         gain = self._sink.set_gain(gain, name)
         if self._verbose:
-            print "Set " + name + " gain to:", gain
+            print("Set " + name + " gain to:", gain)
 
     def set_bandwidth(self, bw):
         try:
             clipped_bw = self[BWIDTH_RANGE_KEY].clip(bw)
         except:
             if self._verbose:
-                print "couldn't clip bandwidth"
+                print("couldn't clip bandwidth")
             return
 
         if self._sink.get_bandwidth() != clipped_bw:
             bw = self._sink.set_bandwidth(clipped_bw)
 
             if self._verbose:
-                print "Set bandwidth to:", bw
+                print("Set bandwidth to:", bw)
 
     def set_dc_offset(self, value):
         correction = complex( self[DC_OFFSET_REAL], self[DC_OFFSET_IMAG] )
@@ -315,9 +315,9 @@ class top_block(gr.top_block, pubsub):
             self._sink.set_dc_offset( correction )
 
             if self._verbose:
-                print "Set DC offset to", correction
+                print("Set DC offset to", correction)
         except RuntimeError as ex:
-            print ex
+            print(ex)
 
     def set_iq_balance(self, value):
         correction = complex( self[IQ_BALANCE_MAG], self[IQ_BALANCE_PHA] )
@@ -326,16 +326,16 @@ class top_block(gr.top_block, pubsub):
             self._sink.set_iq_balance( correction )
 
             if self._verbose:
-                print "Set IQ balance to", correction
+                print("Set IQ balance to", correction)
         except RuntimeError as ex:
-            print ex
+            print(ex)
 
     def set_freq(self, freq):
         if freq is None:
             f = self[FREQ_RANGE_KEY]
             freq = float(f.start()+f.stop())/2.0
             if self._verbose:
-                print "Using auto-calculated mid-point frequency"
+                print("Using auto-calculated mid-point frequency")
             self[TX_FREQ_KEY] = freq
             return
 
@@ -343,22 +343,22 @@ class top_block(gr.top_block, pubsub):
         if freq is not None:
             self._freq = freq
             if self._verbose:
-                print "Set center frequency to", freq
+                print("Set center frequency to", freq)
         elif self._verbose:
-            print "Failed to set freq."
+            print("Failed to set freq.")
         return freq
 
     def set_freq_corr(self, ppm):
         if ppm is None:
             ppm = 0.0
             if self._verbose:
-                print "Using frequency corrrection of", ppm
+                print("Using frequency corrrection of", ppm)
             self[FREQ_CORR_KEY] = ppm
             return
 
         ppm = self._sink.set_freq_corr(ppm)
         if self._verbose:
-            print "Set frequency correction to:", ppm
+            print("Set frequency correction to:", ppm)
 
     def set_waveform_freq(self, freq):
         if self[TYPE_KEY] == analog.GR_SIN_WAVE:
@@ -433,24 +433,24 @@ class top_block(gr.top_block, pubsub):
         self.unlock()
 
         if self._verbose:
-            print "Set baseband modulation to:", waveforms[type]
+            print("Set baseband modulation to:", waveforms[type])
             if type == analog.GR_SIN_WAVE:
-                print "Modulation frequency: %sHz" % (n2s(self[WAVEFORM_FREQ_KEY]),)
-                print "Initial phase:", self[WAVEFORM_OFFSET_KEY]
+                print("Modulation frequency: %sHz" % (n2s(self[WAVEFORM_FREQ_KEY]),))
+                print("Initial phase:", self[WAVEFORM_OFFSET_KEY])
             elif type == "2tone":
-                print "Tone 1: %sHz" % (n2s(self[WAVEFORM_FREQ_KEY]),)
-                print "Tone 2: %sHz" % (n2s(self[WAVEFORM2_FREQ_KEY]),)
+                print("Tone 1: %sHz" % (n2s(self[WAVEFORM_FREQ_KEY]),))
+                print("Tone 2: %sHz" % (n2s(self[WAVEFORM2_FREQ_KEY]),))
             elif type == "sweep":
-                print "Sweeping across %sHz to %sHz" % (n2s(-self[WAVEFORM_FREQ_KEY]/2.0),n2s(self[WAVEFORM_FREQ_KEY]/2.0))
-                print "Sweep rate: %sHz" % (n2s(self[WAVEFORM2_FREQ_KEY]),)
+                print("Sweeping across %sHz to %sHz" % (n2s(-self[WAVEFORM_FREQ_KEY]/2.0),n2s(self[WAVEFORM_FREQ_KEY]/2.0)))
+                print("Sweep rate: %sHz" % (n2s(self[WAVEFORM2_FREQ_KEY]),))
             elif type == "gsm":
-                print "GSM Burst Sequence"
-            print "TX amplitude:", self[AMPLITUDE_KEY]
+                print("GSM Burst Sequence")
+            print("TX amplitude:", self[AMPLITUDE_KEY])
 
     def set_amplitude(self, amplitude):
         if amplitude < 0.0 or amplitude > 1.0:
             if self._verbose:
-                print "Amplitude out of range:", amplitude
+                print("Amplitude out of range:", amplitude)
             return False
 
         if self[TYPE_KEY] in (analog.GR_SIN_WAVE, analog.GR_CONST_WAVE, analog.GR_GAUSSIAN, analog.GR_UNIFORM):
@@ -466,7 +466,7 @@ class top_block(gr.top_block, pubsub):
             return True # Waveform not yet set
 
         if self._verbose:
-            print "Set amplitude to:", amplitude
+            print("Set amplitude to:", amplitude)
         return True
 
 def get_options():
@@ -525,19 +525,19 @@ def get_options():
 # the below does not run.
 def test_main():
     if gr.enable_realtime_scheduling() != gr.RT_OK:
-        print "Note: failed to enable realtime scheduling, continuing"
+        print("Note: failed to enable realtime scheduling, continuing")
 
     # Grab command line options and create top block
     try:
         (options, args) = get_options()
         tb = top_block(options, args)
 
-    except RuntimeError, e:
-        print e
+    except RuntimeError as e:
+        print(e)
         sys.exit(1)
 
     tb.start()
-    raw_input('Press Enter to quit: ')
+    input('Press Enter to quit: ')
     tb.stop()
     tb.wait()
 
diff --git a/cmake/Modules/FindGnuradioFCD.cmake b/cmake/Modules/FindGnuradioFCD.cmake
new file mode 100644
index 0000000..e7d7670
--- /dev/null
+++ b/cmake/Modules/FindGnuradioFCD.cmake
@@ -0,0 +1,34 @@
+INCLUDE(FindPkgConfig)
+PKG_CHECK_MODULES(PC_GNURADIO_FCD gnuradio-fcd)
+
+FIND_PATH(
+    GNURADIO_FCD_INCLUDE_DIRS
+    NAMES gnuradio/fcd/api.h
+    HINTS $ENV{GNURADIO_FCD_DIR}/include
+        ${PC_GNURADIO_FCD_INCLUDEDIR}
+    PATHS /usr/local/include
+          /usr/include
+)
+
+FIND_LIBRARY(
+    GNURADIO_FCD_LIBRARIES
+    NAMES gnuradio-fcd
+    HINTS $ENV{GNURADIO_FCD_DIR}/lib
+        ${PC_GNURADIO_FCD_LIBDIR}
+    PATHS /usr/local/lib
+          /usr/local/lib64
+          /usr/lib
+          /usr/lib64
+)
+
+if(GNURADIO_FCD_INCLUDE_DIRS AND GNURADIO_FCD_LIBRARIES)
+  set(GNURADIO_FCD_FOUND TRUE CACHE INTERNAL "gnuradio-fcd found")
+  message(STATUS "Found gnuradio-fcd: ${GNURADIO_FCD_INCLUDE_DIRS}, ${GNURADIO_FCD_LIBRARIES}")
+else(GNURADIO_FCD_INCLUDE_DIRS AND GNURADIO_FCD_LIBRARIES)
+  set(GNURADIO_FCD_FOUND FALSE CACHE INTERNAL "gnuradio-fcd found")
+  message(STATUS "gnuradio-fcd not found.")
+endif(GNURADIO_FCD_INCLUDE_DIRS AND GNURADIO_FCD_LIBRARIES)
+
+INCLUDE(FindPackageHandleStandardArgs)
+FIND_PACKAGE_HANDLE_STANDARD_ARGS(GNURADIO_FCD DEFAULT_MSG GNURADIO_FCD_LIBRARIES GNURADIO_FCD_INCLUDE_DIRS)
+MARK_AS_ADVANCED(GNURADIO_FCD_LIBRARIES GNURADIO_FCD_INCLUDE_DIRS)
diff --git a/cmake/Modules/FindGnuradioFCDPP.cmake b/cmake/Modules/FindGnuradioFCDPP.cmake
new file mode 100644
index 0000000..c6f03f1
--- /dev/null
+++ b/cmake/Modules/FindGnuradioFCDPP.cmake
@@ -0,0 +1,34 @@
+INCLUDE(FindPkgConfig)
+PKG_CHECK_MODULES(PC_GNURADIO_FCDPP gnuradio-fcdproplus)
+
+FIND_PATH(
+    GNURADIO_FCDPP_INCLUDE_DIRS
+    NAMES fcdproplus/api.h
+    HINTS $ENV{GNURADIO_FCDPP_DIR}/include
+        ${PC_GNURADIO_FCDPP_INCLUDEDIR}
+    PATHS /usr/local/include
+          /usr/include
+)
+
+FIND_LIBRARY(
+    GNURADIO_FCDPP_LIBRARIES
+    NAMES gnuradio-fcdproplus
+    HINTS $ENV{GNURADIO_FCDPP_DIR}/lib
+        ${PC_GNURADIO_FCDPP_LIBDIR}
+    PATHS /usr/local/lib
+          /usr/local/lib64
+          /usr/lib
+          /usr/lib64
+)
+
+if(GNURADIO_FCDPP_INCLUDE_DIRS AND GNURADIO_FCDPP_LIBRARIES)
+  set(GNURADIO_FCDPP_FOUND TRUE CACHE INTERNAL "gnuradio-fcdproplus found")
+  message(STATUS "Found gnuradio-fcdproplus: ${GNURADIO_FCDPP_INCLUDE_DIRS}, ${GNURADIO_FCDPP_LIBRARIES}")
+else(GNURADIO_FCDPP_INCLUDE_DIRS AND GNURADIO_FCDPP_LIBRARIES)
+  set(GNURADIO_FCDPP_FOUND FALSE CACHE INTERNAL "gnuradio-fcdproplus found")
+  message(STATUS "gnuradio-fcdproplus not found.")
+endif(GNURADIO_FCDPP_INCLUDE_DIRS AND GNURADIO_FCDPP_LIBRARIES)
+
+INCLUDE(FindPackageHandleStandardArgs)
+FIND_PACKAGE_HANDLE_STANDARD_ARGS(GNURADIO_FCDPP DEFAULT_MSG GNURADIO_FCDPP_LIBRARIES GNURADIO_FCDPP_INCLUDE_DIRS)
+MARK_AS_ADVANCED(GNURADIO_FCDPP_LIBRARIES GNURADIO_FCDPP_INCLUDE_DIRS)
diff --git a/cmake/Modules/FindGnuradioIQBalance.cmake b/cmake/Modules/FindGnuradioIQBalance.cmake
new file mode 100644
index 0000000..c381d1c
--- /dev/null
+++ b/cmake/Modules/FindGnuradioIQBalance.cmake
@@ -0,0 +1,29 @@
+INCLUDE(FindPkgConfig)
+PKG_CHECK_MODULES(PC_GNURADIO_IQBALANCE gnuradio-iqbalance)
+
+FIND_PATH(
+    GNURADIO_IQBALANCE_INCLUDE_DIRS
+    NAMES gnuradio/iqbalance/api.h
+    HINTS $ENV{GNURADIO_IQBALANCE_DIR}/include
+        ${PC_GNURADIO_IQBALANCE_INCLUDEDIR}
+        ${CMAKE_INSTALL_PREFIX}/include
+    PATHS /usr/local/include
+          /usr/include
+)
+
+FIND_LIBRARY(
+    GNURADIO_IQBALANCE_LIBRARIES
+    NAMES gnuradio-iqbalance
+    HINTS $ENV{GNURADIO_IQBALANCE_DIR}/lib
+        ${PC_GNURADIO_IQBALANCE_LIBDIR}
+        ${CMAKE_INSTALL_PREFIX}/lib64
+        ${CMAKE_INSTALL_PREFIX}/lib
+    PATHS /usr/local/lib
+          /usr/local/lib64
+          /usr/lib
+          /usr/lib64
+)
+
+INCLUDE(FindPackageHandleStandardArgs)
+FIND_PACKAGE_HANDLE_STANDARD_ARGS(GNURADIO_IQBALANCE DEFAULT_MSG GNURADIO_IQBALANCE_LIBRARIES GNURADIO_IQBALANCE_INCLUDE_DIRS)
+MARK_AS_ADVANCED(GNURADIO_IQBALANCE_LIBRARIES GNURADIO_IQBALANCE_INCLUDE_DIRS)
diff --git a/cmake/Modules/FindGnuradioUHD.cmake b/cmake/Modules/FindGnuradioUHD.cmake
new file mode 100644
index 0000000..f99daf0
--- /dev/null
+++ b/cmake/Modules/FindGnuradioUHD.cmake
@@ -0,0 +1,34 @@
+INCLUDE(FindPkgConfig)
+PKG_CHECK_MODULES(PC_GNURADIO_UHD gnuradio-uhd)
+
+FIND_PATH(
+    GNURADIO_UHD_INCLUDE_DIRS
+    NAMES gnuradio/uhd/api.h
+    HINTS $ENV{GNURADIO_UHD_DIR}/include
+        ${PC_GNURADIO_UHD_INCLUDEDIR}
+    PATHS /usr/local/include
+          /usr/include
+)
+
+FIND_LIBRARY(
+    GNURADIO_UHD_LIBRARIES
+    NAMES gnuradio-uhd
+    HINTS $ENV{GNURADIO_UHD_DIR}/lib
+        ${PC_GNURADIO_UHD_LIBDIR}
+    PATHS /usr/local/lib
+          /usr/local/lib64
+          /usr/lib
+          /usr/lib64
+)
+
+if(GNURADIO_UHD_INCLUDE_DIRS AND GNURADIO_UHD_LIBRARIES)
+  set(GNURADIO_UHD_FOUND TRUE CACHE INTERNAL "gnuradio-uhd found")
+  message(STATUS "Found gnuradio-uhd: ${GNURADIO_UHD_INCLUDE_DIRS}, ${GNURADIO_UHD_LIBRARIES}")
+else(GNURADIO_UHD_INCLUDE_DIRS AND GNURADIO_UHD_LIBRARIES)
+  set(GNURADIO_UHD_FOUND FALSE CACHE INTERNAL "gnuradio-uhd found")
+  message(STATUS "gnuradio-uhd not found.")
+endif(GNURADIO_UHD_INCLUDE_DIRS AND GNURADIO_UHD_LIBRARIES)
+
+INCLUDE(FindPackageHandleStandardArgs)
+FIND_PACKAGE_HANDLE_STANDARD_ARGS(GNURADIO_UHD DEFAULT_MSG GNURADIO_UHD_LIBRARIES GNURADIO_UHD_INCLUDE_DIRS)
+MARK_AS_ADVANCED(GNURADIO_UHD_LIBRARIES GNURADIO_UHD_INCLUDE_DIRS)
diff --git a/cmake/Modules/FindUHD.cmake b/cmake/Modules/FindUHD.cmake
new file mode 100644
index 0000000..b4d12b6
--- /dev/null
+++ b/cmake/Modules/FindUHD.cmake
@@ -0,0 +1,28 @@
+########################################################################
+# Find the library for the USRP Hardware Driver
+########################################################################
+
+INCLUDE(FindPkgConfig)
+PKG_CHECK_MODULES(PC_UHD uhd)
+
+FIND_PATH(
+    UHD_INCLUDE_DIRS
+    NAMES uhd/config.hpp
+    HINTS $ENV{UHD_DIR}/include
+        ${PC_UHD_INCLUDEDIR}
+    PATHS /usr/local/include
+          /usr/include
+)
+
+FIND_LIBRARY(
+    UHD_LIBRARIES
+    NAMES uhd
+    HINTS $ENV{UHD_DIR}/lib
+        ${PC_UHD_LIBDIR}
+    PATHS /usr/local/lib
+          /usr/lib
+)
+
+INCLUDE(FindPackageHandleStandardArgs)
+FIND_PACKAGE_HANDLE_STANDARD_ARGS(UHD DEFAULT_MSG UHD_LIBRARIES UHD_INCLUDE_DIRS)
+MARK_AS_ADVANCED(UHD_LIBRARIES UHD_INCLUDE_DIRS)
diff --git a/cmake/Modules/GrComponent.cmake b/cmake/Modules/GrComponent.cmake
new file mode 100644
index 0000000..22b0ea4
--- /dev/null
+++ b/cmake/Modules/GrComponent.cmake
@@ -0,0 +1,115 @@
+# Copyright 2010-2011 Free Software Foundation, Inc.
+#
+# This file is part of GNU Radio
+#
+# GNU Radio is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3, or (at your option)
+# any later version.
+#
+# GNU Radio is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GNU Radio; see the file COPYING.  If not, write to
+# the Free Software Foundation, Inc., 51 Franklin Street,
+# Boston, MA 02110-1301, USA.
+
+if(DEFINED __INCLUDED_GR_COMPONENT_CMAKE)
+    return()
+endif()
+set(__INCLUDED_GR_COMPONENT_CMAKE TRUE)
+
+set(_gr_enabled_components "" CACHE INTERNAL "" FORCE)
+set(_gr_disabled_components "" CACHE INTERNAL "" FORCE)
+
+if(NOT DEFINED ENABLE_DEFAULT)
+    set(ENABLE_DEFAULT ON)
+    message(STATUS "")
+    message(STATUS "The build system will automatically enable all components.")
+    message(STATUS "Use -DENABLE_DEFAULT=OFF to disable components by default.")
+endif()
+
+########################################################################
+# Register a component into the system
+# - name: canonical component name
+# - var: variable for enabled status
+# - argn: list of dependencies
+########################################################################
+function(GR_REGISTER_COMPONENT name var)
+    include(CMakeDependentOption)
+    message(STATUS "")
+    message(STATUS "Configuring ${name} support...")
+    foreach(dep ${ARGN})
+        message(STATUS "  Dependency ${dep} = ${${dep}}")
+    endforeach(dep)
+
+    #if the user set the var to force, we note this
+    if("${${var}}" STREQUAL "FORCE")
+        set(${var} ON)
+        set(var_force TRUE)
+    else()
+        set(var_force FALSE)
+    endif()
+
+    #rewrite the dependency list so that deps that are also components use the cached version
+    unset(comp_deps)
+    foreach(dep ${ARGN})
+        list(FIND _gr_enabled_components ${dep} dep_enb_index)
+        list(FIND _gr_disabled_components ${dep} dep_dis_index)
+        if (${dep_enb_index} EQUAL -1 AND ${dep_dis_index} EQUAL -1)
+            list(APPEND comp_deps ${dep})
+        else()
+            list(APPEND comp_deps ${dep}_cached) #is a component, use cached version
+        endif()
+    endforeach(dep)
+
+    #setup the dependent option for this component
+    CMAKE_DEPENDENT_OPTION(${var} "enable ${name} support" ${ENABLE_DEFAULT} "${comp_deps}" OFF)
+    set(${var} "${${var}}" PARENT_SCOPE)
+    set(${var}_cached "${${var}}" CACHE INTERNAL "" FORCE)
+
+    #force was specified, but the dependencies were not met
+    if(NOT ${var} AND var_force)
+        message(FATAL_ERROR "user force-enabled ${name} but configuration checked failed")
+    endif()
+
+    #append the component into one of the lists
+    if(${var})
+        message(STATUS "  Enabling ${name} support.")
+        list(APPEND _gr_enabled_components ${name})
+    else(${var})
+        message(STATUS "  Disabling ${name} support.")
+        list(APPEND _gr_disabled_components ${name})
+    endif(${var})
+    message(STATUS "  Override with -D${var}=ON/OFF")
+
+    #make components lists into global variables
+    set(_gr_enabled_components ${_gr_enabled_components} CACHE INTERNAL "" FORCE)
+    set(_gr_disabled_components ${_gr_disabled_components} CACHE INTERNAL "" FORCE)
+endfunction(GR_REGISTER_COMPONENT)
+
+########################################################################
+# Print the registered component summary
+########################################################################
+function(GR_PRINT_COMPONENT_SUMMARY)
+    message(STATUS "")
+    message(STATUS "######################################################")
+    message(STATUS "# gr-osmosdr enabled components                         ")
+    message(STATUS "######################################################")
+    foreach(comp ${_gr_enabled_components})
+        message(STATUS "  * ${comp}")
+    endforeach(comp)
+
+    message(STATUS "")
+    message(STATUS "######################################################")
+    message(STATUS "# gr-osmosdr disabled components                        ")
+    message(STATUS "######################################################")
+    foreach(comp ${_gr_disabled_components})
+        message(STATUS "  * ${comp}")
+    endforeach(comp)
+
+    message(STATUS "")
+endfunction(GR_PRINT_COMPONENT_SUMMARY)
diff --git a/cmake/Modules/GrMiscUtils.cmake b/cmake/Modules/GrMiscUtils.cmake
new file mode 100644
index 0000000..747eb1a
--- /dev/null
+++ b/cmake/Modules/GrMiscUtils.cmake
@@ -0,0 +1,519 @@
+# Copyright 2010-2011,2014 Free Software Foundation, Inc.
+#
+# This file is part of GNU Radio
+#
+# GNU Radio is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3, or (at your option)
+# any later version.
+#
+# GNU Radio is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GNU Radio; see the file COPYING.  If not, write to
+# the Free Software Foundation, Inc., 51 Franklin Street,
+# Boston, MA 02110-1301, USA.
+
+if(DEFINED __INCLUDED_GR_MISC_UTILS_CMAKE)
+    return()
+endif()
+set(__INCLUDED_GR_MISC_UTILS_CMAKE TRUE)
+
+########################################################################
+# Set global variable macro.
+# Used for subdirectories to export settings.
+# Example: include and library paths.
+########################################################################
+function(GR_SET_GLOBAL var)
+    set(${var} ${ARGN} CACHE INTERNAL "" FORCE)
+endfunction(GR_SET_GLOBAL)
+
+########################################################################
+# Set the pre-processor definition if the condition is true.
+#  - def the pre-processor definition to set and condition name
+########################################################################
+function(GR_ADD_COND_DEF def)
+    if(${def})
+        add_definitions(-D${def})
+    endif(${def})
+endfunction(GR_ADD_COND_DEF)
+
+########################################################################
+# Check for a header and conditionally set a compile define.
+#  - hdr the relative path to the header file
+#  - def the pre-processor definition to set
+########################################################################
+function(GR_CHECK_HDR_N_DEF hdr def)
+    include(CheckIncludeFileCXX)
+    CHECK_INCLUDE_FILE_CXX(${hdr} ${def})
+    GR_ADD_COND_DEF(${def})
+endfunction(GR_CHECK_HDR_N_DEF)
+
+########################################################################
+# Include subdirectory macro.
+# Sets the CMake directory variables,
+# includes the subdirectory CMakeLists.txt,
+# resets the CMake directory variables.
+#
+# This macro includes subdirectories rather than adding them
+# so that the subdirectory can affect variables in the level above.
+# This provides a work-around for the lack of convenience libraries.
+# This way a subdirectory can append to the list of library sources.
+########################################################################
+macro(GR_INCLUDE_SUBDIRECTORY subdir)
+    #insert the current directories on the front of the list
+    list(INSERT _cmake_source_dirs 0 ${CMAKE_CURRENT_SOURCE_DIR})
+    list(INSERT _cmake_binary_dirs 0 ${CMAKE_CURRENT_BINARY_DIR})
+
+    #set the current directories to the names of the subdirs
+    set(CMAKE_CURRENT_SOURCE_DIR ${CMAKE_CURRENT_SOURCE_DIR}/${subdir})
+    set(CMAKE_CURRENT_BINARY_DIR ${CMAKE_CURRENT_BINARY_DIR}/${subdir})
+
+    #include the subdirectory CMakeLists to run it
+    file(MAKE_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR})
+    include(${CMAKE_CURRENT_SOURCE_DIR}/CMakeLists.txt)
+
+    #reset the value of the current directories
+    list(GET _cmake_source_dirs 0 CMAKE_CURRENT_SOURCE_DIR)
+    list(GET _cmake_binary_dirs 0 CMAKE_CURRENT_BINARY_DIR)
+
+    #pop the subdir names of the front of the list
+    list(REMOVE_AT _cmake_source_dirs 0)
+    list(REMOVE_AT _cmake_binary_dirs 0)
+endmacro(GR_INCLUDE_SUBDIRECTORY)
+
+########################################################################
+# Check if a compiler flag works and conditionally set a compile define.
+#  - flag the compiler flag to check for
+#  - have the variable to set with result
+########################################################################
+macro(GR_ADD_CXX_COMPILER_FLAG_IF_AVAILABLE flag have)
+    include(CheckCXXCompilerFlag)
+    CHECK_CXX_COMPILER_FLAG(${flag} ${have})
+    if(${have})
+        add_definitions(${flag})
+    endif(${have})
+endmacro(GR_ADD_CXX_COMPILER_FLAG_IF_AVAILABLE)
+
+########################################################################
+# Generates the .la libtool file
+# This appears to generate libtool files that cannot be used by auto*.
+# Usage GR_LIBTOOL(TARGET [target] DESTINATION [dest])
+# Notice: there is not COMPONENT option, these will not get distributed.
+########################################################################
+function(GR_LIBTOOL)
+    if(NOT DEFINED GENERATE_LIBTOOL)
+        set(GENERATE_LIBTOOL OFF) #disabled by default
+    endif()
+
+    if(GENERATE_LIBTOOL)
+        include(CMakeParseArgumentsCopy)
+        CMAKE_PARSE_ARGUMENTS(GR_LIBTOOL "" "TARGET;DESTINATION" "" ${ARGN})
+
+        find_program(LIBTOOL libtool)
+        if(LIBTOOL)
+            include(CMakeMacroLibtoolFile)
+            CREATE_LIBTOOL_FILE(${GR_LIBTOOL_TARGET} /${GR_LIBTOOL_DESTINATION})
+        endif(LIBTOOL)
+    endif(GENERATE_LIBTOOL)
+
+endfunction(GR_LIBTOOL)
+
+########################################################################
+# Do standard things to the library target
+# - set target properties
+# - make install rules
+# Also handle gnuradio custom naming conventions w/ extras mode.
+########################################################################
+function(GR_LIBRARY_FOO target)
+    #parse the arguments for component names
+    include(CMakeParseArgumentsCopy)
+    CMAKE_PARSE_ARGUMENTS(GR_LIBRARY "" "RUNTIME_COMPONENT;DEVEL_COMPONENT" "" ${ARGN})
+
+    #set additional target properties
+    set_target_properties(${target} PROPERTIES SOVERSION ${LIBVER})
+
+    #install the generated files like so...
+    install(TARGETS ${target}
+        LIBRARY DESTINATION ${GR_LIBRARY_DIR} COMPONENT ${GR_LIBRARY_RUNTIME_COMPONENT} # .so/.dylib file
+        ARCHIVE DESTINATION ${GR_LIBRARY_DIR} COMPONENT ${GR_LIBRARY_DEVEL_COMPONENT}   # .lib file
+        RUNTIME DESTINATION ${GR_RUNTIME_DIR} COMPONENT ${GR_LIBRARY_RUNTIME_COMPONENT} # .dll file
+    )
+
+    #extras mode enabled automatically on linux
+    if(NOT DEFINED LIBRARY_EXTRAS)
+        set(LIBRARY_EXTRAS ${LINUX})
+    endif()
+
+    #special extras mode to enable alternative naming conventions
+    if(LIBRARY_EXTRAS)
+
+        #create .la file before changing props
+        GR_LIBTOOL(TARGET ${target} DESTINATION ${GR_LIBRARY_DIR})
+
+        #give the library a special name with ultra-zero soversion
+        set_target_properties(${target} PROPERTIES OUTPUT_NAME ${target}-${LIBVER} SOVERSION "0.0.0")
+        set(target_name lib${target}-${LIBVER}.so.0.0.0)
+
+        #custom command to generate symlinks
+        add_custom_command(
+            TARGET ${target}
+            POST_BUILD
+            COMMAND ${CMAKE_COMMAND} -E create_symlink ${target_name} ${CMAKE_CURRENT_BINARY_DIR}/lib${target}.so
+            COMMAND ${CMAKE_COMMAND} -E create_symlink ${target_name} ${CMAKE_CURRENT_BINARY_DIR}/lib${target}-${LIBVER}.so.0
+            COMMAND ${CMAKE_COMMAND} -E touch ${target_name} #so the symlinks point to something valid so cmake 2.6 will install
+        )
+
+        #and install the extra symlinks
+        install(
+            FILES
+            ${CMAKE_CURRENT_BINARY_DIR}/lib${target}.so
+            ${CMAKE_CURRENT_BINARY_DIR}/lib${target}-${LIBVER}.so.0
+            DESTINATION ${GR_LIBRARY_DIR} COMPONENT ${GR_LIBRARY_RUNTIME_COMPONENT}
+        )
+
+    endif(LIBRARY_EXTRAS)
+endfunction(GR_LIBRARY_FOO)
+
+########################################################################
+# Create a dummy custom command that depends on other targets.
+# Usage:
+#   GR_GEN_TARGET_DEPS(unique_name target_deps <target1> <target2> ...)
+#   ADD_CUSTOM_COMMAND(<the usual args> ${target_deps})
+#
+# Custom command cant depend on targets, but can depend on executables,
+# and executables can depend on targets. So this is the process:
+########################################################################
+function(GR_GEN_TARGET_DEPS name var)
+    file(
+        WRITE ${CMAKE_CURRENT_BINARY_DIR}/${name}.cpp.in
+        "int main(void){return 0;}\n"
+    )
+    execute_process(
+        COMMAND ${CMAKE_COMMAND} -E copy_if_different
+        ${CMAKE_CURRENT_BINARY_DIR}/${name}.cpp.in
+        ${CMAKE_CURRENT_BINARY_DIR}/${name}.cpp
+    )
+    add_executable(${name} ${CMAKE_CURRENT_BINARY_DIR}/${name}.cpp)
+    if(ARGN)
+        add_dependencies(${name} ${ARGN})
+    endif(ARGN)
+
+    if(CMAKE_CROSSCOMPILING)
+        set(${var} "DEPENDS;${name}" PARENT_SCOPE) #cant call command when cross
+    else()
+        set(${var} "DEPENDS;${name};COMMAND;${name}" PARENT_SCOPE)
+    endif()
+endfunction(GR_GEN_TARGET_DEPS)
+
+########################################################################
+# Control use of gr_logger
+# Usage:
+#   GR_LOGGING()
+#
+# Will set ENABLE_GR_LOG to 1 by default.
+# Can manually set with -DENABLE_GR_LOG=0|1
+########################################################################
+function(GR_LOGGING)
+  find_package(Log4cpp)
+
+  OPTION(ENABLE_GR_LOG "Use gr_logger" ON)
+  if(ENABLE_GR_LOG)
+    # If gr_logger is enabled, make it usable
+    add_definitions( -DENABLE_GR_LOG )
+
+    # also test LOG4CPP; if we have it, use this version of the logger
+    # otherwise, default to the stdout/stderr model.
+    if(LOG4CPP_FOUND)
+      SET(HAVE_LOG4CPP True CACHE INTERNAL "" FORCE)
+      add_definitions( -DHAVE_LOG4CPP )
+    else(not LOG4CPP_FOUND)
+      SET(HAVE_LOG4CPP False CACHE INTERNAL "" FORCE)
+      SET(LOG4CPP_INCLUDE_DIRS "" CACHE INTERNAL "" FORCE)
+      SET(LOG4CPP_LIBRARY_DIRS "" CACHE INTERNAL "" FORCE)
+      SET(LOG4CPP_LIBRARIES "" CACHE INTERNAL "" FORCE)
+    endif(LOG4CPP_FOUND)
+
+    SET(ENABLE_GR_LOG ${ENABLE_GR_LOG} CACHE INTERNAL "" FORCE)
+
+  else(ENABLE_GR_LOG)
+    SET(HAVE_LOG4CPP False CACHE INTERNAL "" FORCE)
+    SET(LOG4CPP_INCLUDE_DIRS "" CACHE INTERNAL "" FORCE)
+    SET(LOG4CPP_LIBRARY_DIRS "" CACHE INTERNAL "" FORCE)
+    SET(LOG4CPP_LIBRARIES "" CACHE INTERNAL "" FORCE)
+  endif(ENABLE_GR_LOG)
+
+  message(STATUS "ENABLE_GR_LOG set to ${ENABLE_GR_LOG}.")
+  message(STATUS "HAVE_LOG4CPP set to ${HAVE_LOG4CPP}.")
+  message(STATUS "LOG4CPP_LIBRARIES set to ${LOG4CPP_LIBRARIES}.")
+
+endfunction(GR_LOGGING)
+
+########################################################################
+# Run GRCC to compile .grc files into .py files.
+#
+# Usage: GRCC(filename, directory)
+#    - filenames: List of file name of .grc file
+#    - directory: directory of built .py file - usually in
+#                 ${CMAKE_CURRENT_BINARY_DIR}
+#    - Sets PYFILES: output converted GRC file names to Python files.
+########################################################################
+function(GRCC)
+  # Extract directory from list of args, remove it for the list of filenames.
+  list(GET ARGV -1 directory)
+  list(REMOVE_AT ARGV -1)
+  set(filenames ${ARGV})
+  file(MAKE_DIRECTORY ${directory})
+
+  SET(GRCC_COMMAND ${CMAKE_SOURCE_DIR}/gr-utils/python/grcc)
+
+  # GRCC uses some stuff in grc and gnuradio-runtime, so we force
+  # the known paths here
+  list(APPEND PYTHONPATHS
+    ${CMAKE_SOURCE_DIR}
+    ${CMAKE_SOURCE_DIR}/gnuradio-runtime/python
+    ${CMAKE_SOURCE_DIR}/gnuradio-runtime/lib/swig
+    ${CMAKE_BINARY_DIR}/gnuradio-runtime/lib/swig
+    )
+
+  if(WIN32)
+    #SWIG generates the python library files into a subdirectory.
+    #Therefore, we must append this subdirectory into PYTHONPATH.
+    #Only do this for the python directories matching the following:
+    foreach(pydir ${PYTHONPATHS})
+      get_filename_component(name ${pydir} NAME)
+      if(name MATCHES "^(swig|lib|src)$")
+        list(APPEND PYTHONPATHS ${pydir}/${CMAKE_BUILD_TYPE})
+      endif()
+    endforeach(pydir)
+  endif(WIN32)
+
+  file(TO_NATIVE_PATH "${PYTHONPATHS}" pypath)
+
+  if(UNIX)
+    list(APPEND pypath "$PYTHONPATH")
+    string(REPLACE ";" ":" pypath "${pypath}")
+    set(ENV{PYTHONPATH} ${pypath})
+  endif(UNIX)
+
+  if(WIN32)
+    list(APPEND pypath "%PYTHONPATH%")
+    string(REPLACE ";" "\\;" pypath "${pypath}")
+    #list(APPEND environs "PYTHONPATH=${pypath}")
+    set(ENV{PYTHONPATH} ${pypath})
+  endif(WIN32)
+
+  foreach(f ${filenames})
+    execute_process(
+      COMMAND ${GRCC_COMMAND} -d ${directory} ${f}
+      )
+    string(REPLACE ".grc" ".py" pyfile "${f}")
+    string(REPLACE "${CMAKE_CURRENT_SOURCE_DIR}" "${CMAKE_CURRENT_BINARY_DIR}" pyfile "${pyfile}")
+    list(APPEND pyfiles ${pyfile})
+  endforeach(f)
+
+  set(PYFILES ${pyfiles} PARENT_SCOPE)
+endfunction(GRCC)
+
+########################################################################
+# Check if HAVE_PTHREAD_SETSCHEDPARAM and HAVE_SCHED_SETSCHEDULER
+#  should be defined
+########################################################################
+macro(GR_CHECK_LINUX_SCHED_AVAIL)
+set(CMAKE_REQUIRED_LIBRARIES -lpthread)
+    CHECK_CXX_SOURCE_COMPILES("
+        #include <pthread.h>
+        int main(){
+            pthread_t pthread;
+            pthread_setschedparam(pthread,  0, 0);
+            return 0;
+        } " HAVE_PTHREAD_SETSCHEDPARAM
+    )
+    GR_ADD_COND_DEF(HAVE_PTHREAD_SETSCHEDPARAM)
+
+    CHECK_CXX_SOURCE_COMPILES("
+        #include <sched.h>
+        int main(){
+            pid_t pid;
+            sched_setscheduler(pid, 0, 0);
+            return 0;
+        } " HAVE_SCHED_SETSCHEDULER
+    )
+    GR_ADD_COND_DEF(HAVE_SCHED_SETSCHEDULER)
+endmacro(GR_CHECK_LINUX_SCHED_AVAIL)
+
+########################################################################
+# Macros to generate source and header files from template
+########################################################################
+macro(GR_EXPAND_X_H component root)
+
+  include(GrPython)
+
+  file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/generate_helper.py
+"#!${PYTHON_EXECUTABLE}
+
+import sys, os, re
+sys.path.append('${GR_RUNTIME_PYTHONPATH}')
+os.environ['srcdir'] = '${CMAKE_CURRENT_SOURCE_DIR}'
+os.chdir('${CMAKE_CURRENT_BINARY_DIR}')
+
+if __name__ == '__main__':
+    import build_utils
+    root, inp = sys.argv[1:3]
+    for sig in sys.argv[3:]:
+        name = re.sub ('X+', sig, root)
+        d = build_utils.standard_dict2(name, sig, '${component}')
+        build_utils.expand_template(d, inp)
+")
+
+  #make a list of all the generated headers
+  unset(expanded_files_h)
+  foreach(sig ${ARGN})
+    string(REGEX REPLACE "X+" ${sig} name ${root})
+    list(APPEND expanded_files_h ${CMAKE_CURRENT_BINARY_DIR}/${name}.h)
+  endforeach(sig)
+  unset(name)
+
+  #create a command to generate the headers
+  add_custom_command(
+    OUTPUT ${expanded_files_h}
+    DEPENDS ${CMAKE_CURRENT_SOURCE_DIR}/${root}.h.t
+    COMMAND ${PYTHON_EXECUTABLE} ${PYTHON_DASH_B}
+    ${CMAKE_CURRENT_BINARY_DIR}/generate_helper.py
+    ${root} ${root}.h.t ${ARGN}
+  )
+
+  #install rules for the generated headers
+  list(APPEND generated_includes ${expanded_files_h})
+
+endmacro(GR_EXPAND_X_H)
+
+macro(GR_EXPAND_X_CC_H component root)
+
+  include(GrPython)
+
+  file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/generate_helper.py
+"#!${PYTHON_EXECUTABLE}
+
+import sys, os, re
+sys.path.append('${GR_RUNTIME_PYTHONPATH}')
+os.environ['srcdir'] = '${CMAKE_CURRENT_SOURCE_DIR}'
+os.chdir('${CMAKE_CURRENT_BINARY_DIR}')
+
+if __name__ == '__main__':
+    import build_utils
+    root, inp = sys.argv[1:3]
+    for sig in sys.argv[3:]:
+        name = re.sub ('X+', sig, root)
+        d = build_utils.standard_impl_dict2(name, sig, '${component}')
+        build_utils.expand_template(d, inp)
+")
+
+  #make a list of all the generated files
+  unset(expanded_files_cc)
+  unset(expanded_files_h)
+  foreach(sig ${ARGN})
+    string(REGEX REPLACE "X+" ${sig} name ${root})
+    list(APPEND expanded_files_cc ${CMAKE_CURRENT_BINARY_DIR}/${name}.cc)
+    list(APPEND expanded_files_h  ${CMAKE_CURRENT_BINARY_DIR}/${name}.h)
+  endforeach(sig)
+  unset(name)
+
+  #create a command to generate the source files
+  add_custom_command(
+    OUTPUT ${expanded_files_cc}
+    DEPENDS ${CMAKE_CURRENT_SOURCE_DIR}/${root}.cc.t
+    COMMAND ${PYTHON_EXECUTABLE} ${PYTHON_DASH_B}
+    ${CMAKE_CURRENT_BINARY_DIR}/generate_helper.py
+    ${root} ${root}.cc.t ${ARGN}
+  )
+
+  #create a command to generate the header files
+  add_custom_command(
+    OUTPUT ${expanded_files_h}
+    DEPENDS ${CMAKE_CURRENT_SOURCE_DIR}/${root}.h.t
+    COMMAND ${PYTHON_EXECUTABLE} ${PYTHON_DASH_B}
+    ${CMAKE_CURRENT_BINARY_DIR}/generate_helper.py
+    ${root} ${root}.h.t ${ARGN}
+  )
+
+  #make source files depends on headers to force generation
+  set_source_files_properties(${expanded_files_cc}
+    PROPERTIES OBJECT_DEPENDS "${expanded_files_h}"
+  )
+
+  #install rules for the generated files
+  list(APPEND generated_sources ${expanded_files_cc})
+  list(APPEND generated_headers ${expanded_files_h})
+
+endmacro(GR_EXPAND_X_CC_H)
+
+macro(GR_EXPAND_X_CC_H_IMPL component root)
+
+  include(GrPython)
+
+  file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/generate_helper.py
+"#!${PYTHON_EXECUTABLE}
+
+import sys, os, re
+sys.path.append('${GR_RUNTIME_PYTHONPATH}')
+os.environ['srcdir'] = '${CMAKE_CURRENT_SOURCE_DIR}'
+os.chdir('${CMAKE_CURRENT_BINARY_DIR}')
+
+if __name__ == '__main__':
+    import build_utils
+    root, inp = sys.argv[1:3]
+    for sig in sys.argv[3:]:
+        name = re.sub ('X+', sig, root)
+        d = build_utils.standard_dict(name, sig, '${component}')
+        build_utils.expand_template(d, inp, '_impl')
+")
+
+  #make a list of all the generated files
+  unset(expanded_files_cc_impl)
+  unset(expanded_files_h_impl)
+  unset(expanded_files_h)
+  foreach(sig ${ARGN})
+    string(REGEX REPLACE "X+" ${sig} name ${root})
+    list(APPEND expanded_files_cc_impl ${CMAKE_CURRENT_BINARY_DIR}/${name}_impl.cc)
+    list(APPEND expanded_files_h_impl ${CMAKE_CURRENT_BINARY_DIR}/${name}_impl.h)
+    list(APPEND expanded_files_h ${CMAKE_CURRENT_BINARY_DIR}/../include/gnuradio/${component}/${name}.h)
+  endforeach(sig)
+  unset(name)
+
+  #create a command to generate the _impl.cc files
+  add_custom_command(
+    OUTPUT ${expanded_files_cc_impl}
+    DEPENDS ${CMAKE_CURRENT_SOURCE_DIR}/${root}_impl.cc.t
+    COMMAND ${PYTHON_EXECUTABLE} ${PYTHON_DASH_B}
+    ${CMAKE_CURRENT_BINARY_DIR}/generate_helper.py
+    ${root} ${root}_impl.cc.t ${ARGN}
+  )
+
+  #create a command to generate the _impl.h files
+  add_custom_command(
+    OUTPUT ${expanded_files_h_impl}
+    DEPENDS ${CMAKE_CURRENT_SOURCE_DIR}/${root}_impl.h.t
+    COMMAND ${PYTHON_EXECUTABLE} ${PYTHON_DASH_B}
+    ${CMAKE_CURRENT_BINARY_DIR}/generate_helper.py
+    ${root} ${root}_impl.h.t ${ARGN}
+  )
+
+  #make _impl.cc source files depend on _impl.h to force generation
+  set_source_files_properties(${expanded_files_cc_impl}
+    PROPERTIES OBJECT_DEPENDS "${expanded_files_h_impl}"
+  )
+
+  #make _impl.h source files depend on headers to force generation
+  set_source_files_properties(${expanded_files_h_impl}
+    PROPERTIES OBJECT_DEPENDS "${expanded_files_h}"
+  )
+
+  #install rules for the generated files
+  list(APPEND generated_sources ${expanded_files_cc_impl})
+  list(APPEND generated_headers ${expanded_files_h_impl})
+
+endmacro(GR_EXPAND_X_CC_H_IMPL)
diff --git a/cmake/Modules/GrPlatform.cmake b/cmake/Modules/GrPlatform.cmake
new file mode 100644
index 0000000..fbbea5f
--- /dev/null
+++ b/cmake/Modules/GrPlatform.cmake
@@ -0,0 +1,54 @@
+# Copyright 2011 Free Software Foundation, Inc.
+#
+# This file is part of GNU Radio
+#
+# GNU Radio is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3, or (at your option)
+# any later version.
+#
+# GNU Radio is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GNU Radio; see the file COPYING.  If not, write to
+# the Free Software Foundation, Inc., 51 Franklin Street,
+# Boston, MA 02110-1301, USA.
+
+if(DEFINED __INCLUDED_GR_PLATFORM_CMAKE)
+    return()
+endif()
+set(__INCLUDED_GR_PLATFORM_CMAKE TRUE)
+
+########################################################################
+# Setup additional defines for OS types
+########################################################################
+if(CMAKE_SYSTEM_NAME STREQUAL "Linux")
+    set(LINUX TRUE)
+endif()
+
+if(NOT CMAKE_CROSSCOMPILING AND LINUX AND EXISTS "/etc/debian_version")
+    set(DEBIAN TRUE)
+endif()
+
+if(NOT CMAKE_CROSSCOMPILING AND LINUX AND EXISTS "/etc/redhat-release")
+    set(REDHAT TRUE)
+endif()
+
+if(NOT CMAKE_CROSSCOMPILING AND LINUX AND EXISTS "/etc/slackware-version")
+    set(SLACKWARE TRUE)
+endif()
+
+########################################################################
+# when the library suffix should be 64 (applies to redhat linux family)
+########################################################################
+if (REDHAT OR SLACKWARE)
+    set(LIB64_CONVENTION TRUE)
+endif()
+
+if(NOT DEFINED LIB_SUFFIX AND LIB64_CONVENTION AND CMAKE_SYSTEM_PROCESSOR MATCHES "64$")
+    set(LIB_SUFFIX 64)
+endif()
+set(LIB_SUFFIX ${LIB_SUFFIX} CACHE STRING "lib directory suffix")
diff --git a/cmake/Modules/GrPython.cmake b/cmake/Modules/GrPython.cmake
new file mode 100644
index 0000000..395faff
--- /dev/null
+++ b/cmake/Modules/GrPython.cmake
@@ -0,0 +1,242 @@
+# Copyright 2010-2011 Free Software Foundation, Inc.
+#
+# This file is part of GNU Radio
+#
+# GNU Radio is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3, or (at your option)
+# any later version.
+#
+# GNU Radio is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GNU Radio; see the file COPYING.  If not, write to
+# the Free Software Foundation, Inc., 51 Franklin Street,
+# Boston, MA 02110-1301, USA.
+
+if(DEFINED __INCLUDED_GR_PYTHON_CMAKE)
+    return()
+endif()
+set(__INCLUDED_GR_PYTHON_CMAKE TRUE)
+
+########################################################################
+# Setup the python interpreter:
+# This allows the user to specify a specific interpreter,
+# or finds the interpreter via the built-in cmake module.
+########################################################################
+#this allows the user to override PYTHON_EXECUTABLE
+if(PYTHON_EXECUTABLE)
+
+    set(PYTHONINTERP_FOUND TRUE)
+
+#otherwise if not set, try to automatically find it
+else(PYTHON_EXECUTABLE)
+
+    #use the built-in find script
+    find_package(PythonInterp 2)
+
+    #and if that fails use the find program routine
+    if(NOT PYTHONINTERP_FOUND)
+        find_program(PYTHON_EXECUTABLE NAMES python python2 python2.7 python2.6 python2.5)
+        if(PYTHON_EXECUTABLE)
+            set(PYTHONINTERP_FOUND TRUE)
+        endif(PYTHON_EXECUTABLE)
+    endif(NOT PYTHONINTERP_FOUND)
+
+endif(PYTHON_EXECUTABLE)
+
+if (CMAKE_CROSSCOMPILING)
+    set(QA_PYTHON_EXECUTABLE "/usr/bin/python")
+else (CMAKE_CROSSCOMPILING)
+    set(QA_PYTHON_EXECUTABLE ${PYTHON_EXECUTABLE})
+endif(CMAKE_CROSSCOMPILING)
+
+#make the path to the executable appear in the cmake gui
+set(PYTHON_EXECUTABLE ${PYTHON_EXECUTABLE} CACHE FILEPATH "python interpreter")
+set(QA_PYTHON_EXECUTABLE ${QA_PYTHON_EXECUTABLE} CACHE FILEPATH "python interpreter for QA tests")
+
+#make sure we can use -B with python (introduced in 2.6)
+if(PYTHON_EXECUTABLE)
+    execute_process(
+        COMMAND ${PYTHON_EXECUTABLE} -B -c ""
+        OUTPUT_QUIET ERROR_QUIET
+        RESULT_VARIABLE PYTHON_HAS_DASH_B_RESULT
+    )
+    if(PYTHON_HAS_DASH_B_RESULT EQUAL 0)
+        set(PYTHON_DASH_B "-B")
+    endif()
+endif(PYTHON_EXECUTABLE)
+
+########################################################################
+# Check for the existence of a python module:
+# - desc a string description of the check
+# - mod the name of the module to import
+# - cmd an additional command to run
+# - have the result variable to set
+########################################################################
+macro(GR_PYTHON_CHECK_MODULE desc mod cmd have)
+    message(STATUS "")
+    message(STATUS "Python checking for ${desc}")
+    execute_process(
+        COMMAND ${PYTHON_EXECUTABLE} -c "
+#########################################
+try:
+    import ${mod}
+    assert ${cmd}
+except ImportError, AssertionError: exit(-1)
+except: pass
+#########################################"
+        RESULT_VARIABLE ${have}
+    )
+    if(${have} EQUAL 0)
+        message(STATUS "Python checking for ${desc} - found")
+        set(${have} TRUE)
+    else(${have} EQUAL 0)
+        message(STATUS "Python checking for ${desc} - not found")
+        set(${have} FALSE)
+    endif(${have} EQUAL 0)
+endmacro(GR_PYTHON_CHECK_MODULE)
+
+########################################################################
+# Sets the python installation directory GR_PYTHON_DIR
+########################################################################
+if(NOT DEFINED GR_PYTHON_DIR)
+execute_process(COMMAND ${PYTHON_EXECUTABLE} -c "
+from distutils import sysconfig
+print sysconfig.get_python_lib(plat_specific=True, prefix='')
+" OUTPUT_VARIABLE GR_PYTHON_DIR OUTPUT_STRIP_TRAILING_WHITESPACE
+)
+endif()
+file(TO_CMAKE_PATH ${GR_PYTHON_DIR} GR_PYTHON_DIR)
+
+########################################################################
+# Create an always-built target with a unique name
+# Usage: GR_UNIQUE_TARGET(<description> <dependencies list>)
+########################################################################
+function(GR_UNIQUE_TARGET desc)
+    file(RELATIVE_PATH reldir ${CMAKE_BINARY_DIR} ${CMAKE_CURRENT_BINARY_DIR})
+    execute_process(COMMAND ${PYTHON_EXECUTABLE} -c "import re, hashlib
+unique = hashlib.md5('${reldir}${ARGN}').hexdigest()[:5]
+print(re.sub('\\W', '_', '${desc} ${reldir} ' + unique))"
+    OUTPUT_VARIABLE _target OUTPUT_STRIP_TRAILING_WHITESPACE)
+    add_custom_target(${_target} ALL DEPENDS ${ARGN})
+endfunction(GR_UNIQUE_TARGET)
+
+########################################################################
+# Install python sources (also builds and installs byte-compiled python)
+########################################################################
+function(GR_PYTHON_INSTALL)
+    include(CMakeParseArgumentsCopy)
+    CMAKE_PARSE_ARGUMENTS(GR_PYTHON_INSTALL "" "DESTINATION;COMPONENT" "FILES;PROGRAMS" ${ARGN})
+
+    ####################################################################
+    if(GR_PYTHON_INSTALL_FILES)
+    ####################################################################
+        install(${ARGN}) #installs regular python files
+
+        #create a list of all generated files
+        unset(pysrcfiles)
+        unset(pycfiles)
+        unset(pyofiles)
+        foreach(pyfile ${GR_PYTHON_INSTALL_FILES})
+            get_filename_component(pyfile ${pyfile} ABSOLUTE)
+            list(APPEND pysrcfiles ${pyfile})
+
+            #determine if this file is in the source or binary directory
+            file(RELATIVE_PATH source_rel_path ${CMAKE_CURRENT_SOURCE_DIR} ${pyfile})
+            string(LENGTH "${source_rel_path}" source_rel_path_len)
+            file(RELATIVE_PATH binary_rel_path ${CMAKE_CURRENT_BINARY_DIR} ${pyfile})
+            string(LENGTH "${binary_rel_path}" binary_rel_path_len)
+
+            #and set the generated path appropriately
+            if(${source_rel_path_len} GREATER ${binary_rel_path_len})
+                set(pygenfile ${CMAKE_CURRENT_BINARY_DIR}/${binary_rel_path})
+            else()
+                set(pygenfile ${CMAKE_CURRENT_BINARY_DIR}/${source_rel_path})
+            endif()
+            list(APPEND pycfiles ${pygenfile}c)
+            list(APPEND pyofiles ${pygenfile}o)
+
+            #ensure generation path exists
+            get_filename_component(pygen_path ${pygenfile} PATH)
+            file(MAKE_DIRECTORY ${pygen_path})
+
+        endforeach(pyfile)
+
+        #the command to generate the pyc files
+        add_custom_command(
+            DEPENDS ${pysrcfiles} OUTPUT ${pycfiles}
+            COMMAND ${PYTHON_EXECUTABLE} ${CMAKE_BINARY_DIR}/python_compile_helper.py ${pysrcfiles} ${pycfiles}
+        )
+
+        #the command to generate the pyo files
+        add_custom_command(
+            DEPENDS ${pysrcfiles} OUTPUT ${pyofiles}
+            COMMAND ${PYTHON_EXECUTABLE} -O ${CMAKE_BINARY_DIR}/python_compile_helper.py ${pysrcfiles} ${pyofiles}
+        )
+
+        #create install rule and add generated files to target list
+        set(python_install_gen_targets ${pycfiles} ${pyofiles})
+        install(FILES ${python_install_gen_targets}
+            DESTINATION ${GR_PYTHON_INSTALL_DESTINATION}
+            COMPONENT ${GR_PYTHON_INSTALL_COMPONENT}
+        )
+
+
+    ####################################################################
+    elseif(GR_PYTHON_INSTALL_PROGRAMS)
+    ####################################################################
+        file(TO_NATIVE_PATH ${PYTHON_EXECUTABLE} pyexe_native)
+
+        if (CMAKE_CROSSCOMPILING)
+           set(pyexe_native "/usr/bin/env python")
+        endif()
+
+        foreach(pyfile ${GR_PYTHON_INSTALL_PROGRAMS})
+            get_filename_component(pyfile_name ${pyfile} NAME)
+            get_filename_component(pyfile ${pyfile} ABSOLUTE)
+            string(REPLACE "${CMAKE_SOURCE_DIR}" "${CMAKE_BINARY_DIR}" pyexefile "${pyfile}.exe")
+            list(APPEND python_install_gen_targets ${pyexefile})
+
+            get_filename_component(pyexefile_path ${pyexefile} PATH)
+            file(MAKE_DIRECTORY ${pyexefile_path})
+
+            add_custom_command(
+                OUTPUT ${pyexefile} DEPENDS ${pyfile}
+                COMMAND ${PYTHON_EXECUTABLE} -c
+                "open('${pyexefile}','w').write('\#!${pyexe_native}\\n'+open('${pyfile}').read())"
+                COMMENT "Shebangin ${pyfile_name}"
+                VERBATIM
+            )
+
+            #on windows, python files need an extension to execute
+            get_filename_component(pyfile_ext ${pyfile} EXT)
+            if(WIN32 AND NOT pyfile_ext)
+                set(pyfile_name "${pyfile_name}.py")
+            endif()
+
+            install(PROGRAMS ${pyexefile} RENAME ${pyfile_name}
+                DESTINATION ${GR_PYTHON_INSTALL_DESTINATION}
+                COMPONENT ${GR_PYTHON_INSTALL_COMPONENT}
+            )
+        endforeach(pyfile)
+
+    endif()
+
+    GR_UNIQUE_TARGET("pygen" ${python_install_gen_targets})
+
+endfunction(GR_PYTHON_INSTALL)
+
+########################################################################
+# Write the python helper script that generates byte code files
+########################################################################
+file(WRITE ${CMAKE_BINARY_DIR}/python_compile_helper.py "
+import sys, py_compile
+files = sys.argv[1:]
+srcs, gens = files[:len(files)/2], files[len(files)/2:]
+for src, gen in zip(srcs, gens):
+    py_compile.compile(file=src, cfile=gen, doraise=True)
+")
diff --git a/cmake/Modules/GrTest.cmake b/cmake/Modules/GrTest.cmake
new file mode 100644
index 0000000..62caab4
--- /dev/null
+++ b/cmake/Modules/GrTest.cmake
@@ -0,0 +1,143 @@
+# Copyright 2010-2011 Free Software Foundation, Inc.
+#
+# This file is part of GNU Radio
+#
+# GNU Radio is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3, or (at your option)
+# any later version.
+#
+# GNU Radio is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GNU Radio; see the file COPYING.  If not, write to
+# the Free Software Foundation, Inc., 51 Franklin Street,
+# Boston, MA 02110-1301, USA.
+
+if(DEFINED __INCLUDED_GR_TEST_CMAKE)
+    return()
+endif()
+set(__INCLUDED_GR_TEST_CMAKE TRUE)
+
+########################################################################
+# Add a unit test and setup the environment for a unit test.
+# Takes the same arguments as the ADD_TEST function.
+#
+# Before calling set the following variables:
+# GR_TEST_TARGET_DEPS  - built targets for the library path
+# GR_TEST_LIBRARY_DIRS - directories for the library path
+# GR_TEST_PYTHON_DIRS  - directories for the python path
+# GR_TEST_ENVIRONS  - other environment key/value pairs
+########################################################################
+function(GR_ADD_TEST test_name)
+
+        #Ensure that the build exe also appears in the PATH.
+        list(APPEND GR_TEST_TARGET_DEPS ${ARGN})
+
+        #In the land of windows, all libraries must be in the PATH.
+        #Since the dependent libraries are not yet installed,
+        #we must manually set them in the PATH to run tests.
+        #The following appends the path of a target dependency.
+        foreach(target ${GR_TEST_TARGET_DEPS})
+            get_target_property(location ${target} LOCATION)
+            if(location)
+                get_filename_component(path ${location} PATH)
+                string(REGEX REPLACE "\\$\\(.*\\)" ${CMAKE_BUILD_TYPE} path ${path})
+                list(APPEND GR_TEST_LIBRARY_DIRS ${path})
+            endif(location)
+        endforeach(target)
+
+    if(WIN32)
+        #SWIG generates the python library files into a subdirectory.
+        #Therefore, we must append this subdirectory into PYTHONPATH.
+        #Only do this for the python directories matching the following:
+        foreach(pydir ${GR_TEST_PYTHON_DIRS})
+            get_filename_component(name ${pydir} NAME)
+            if(name MATCHES "^(swig|lib|src)$")
+                list(APPEND GR_TEST_PYTHON_DIRS ${pydir}/${CMAKE_BUILD_TYPE})
+            endif()
+        endforeach(pydir)
+    endif(WIN32)
+
+    file(TO_NATIVE_PATH ${CMAKE_CURRENT_SOURCE_DIR} srcdir)
+    file(TO_NATIVE_PATH "${GR_TEST_LIBRARY_DIRS}" libpath) #ok to use on dir list?
+    file(TO_NATIVE_PATH "${GR_TEST_PYTHON_DIRS}" pypath) #ok to use on dir list?
+
+    set(environs "VOLK_GENERIC=1" "GR_DONT_LOAD_PREFS=1" "srcdir=${srcdir}")
+    list(APPEND environs ${GR_TEST_ENVIRONS})
+
+    #http://www.cmake.org/pipermail/cmake/2009-May/029464.html
+    #Replaced this add test + set environs code with the shell script generation.
+    #Its nicer to be able to manually run the shell script to diagnose problems.
+    #ADD_TEST(${ARGV})
+    #SET_TESTS_PROPERTIES(${test_name} PROPERTIES ENVIRONMENT "${environs}")
+
+    if(UNIX)
+        set(LD_PATH_VAR "LD_LIBRARY_PATH")
+        if(APPLE)
+            set(LD_PATH_VAR "DYLD_LIBRARY_PATH")
+        endif()
+
+        set(binpath "${CMAKE_CURRENT_BINARY_DIR}:$PATH")
+        list(APPEND libpath "$${LD_PATH_VAR}")
+        list(APPEND pypath "$PYTHONPATH")
+
+        #replace list separator with the path separator
+        string(REPLACE ";" ":" libpath "${libpath}")
+        string(REPLACE ";" ":" pypath "${pypath}")
+        list(APPEND environs "PATH=${binpath}" "${LD_PATH_VAR}=${libpath}" "PYTHONPATH=${pypath}")
+
+        #generate a bat file that sets the environment and runs the test
+	if (CMAKE_CROSSCOMPILING)
+                set(SHELL "/bin/sh")
+        else(CMAKE_CROSSCOMPILING)
+                find_program(SHELL sh)
+        endif(CMAKE_CROSSCOMPILING)
+        set(sh_file ${CMAKE_CURRENT_BINARY_DIR}/${test_name}_test.sh)
+        file(WRITE ${sh_file} "#!${SHELL}\n")
+        #each line sets an environment variable
+        foreach(environ ${environs})
+            file(APPEND ${sh_file} "export ${environ}\n")
+        endforeach(environ)
+        #load the command to run with its arguments
+        foreach(arg ${ARGN})
+            file(APPEND ${sh_file} "${arg} ")
+        endforeach(arg)
+        file(APPEND ${sh_file} "\n")
+
+        #make the shell file executable
+        execute_process(COMMAND chmod +x ${sh_file})
+
+        add_test(${test_name} ${SHELL} ${sh_file})
+
+    endif(UNIX)
+
+    if(WIN32)
+        list(APPEND libpath ${DLL_PATHS} "%PATH%")
+        list(APPEND pypath "%PYTHONPATH%")
+
+        #replace list separator with the path separator (escaped)
+        string(REPLACE ";" "\\;" libpath "${libpath}")
+        string(REPLACE ";" "\\;" pypath "${pypath}")
+        list(APPEND environs "PATH=${libpath}" "PYTHONPATH=${pypath}")
+
+        #generate a bat file that sets the environment and runs the test
+        set(bat_file ${CMAKE_CURRENT_BINARY_DIR}/${test_name}_test.bat)
+        file(WRITE ${bat_file} "@echo off\n")
+        #each line sets an environment variable
+        foreach(environ ${environs})
+            file(APPEND ${bat_file} "SET ${environ}\n")
+        endforeach(environ)
+        #load the command to run with its arguments
+        foreach(arg ${ARGN})
+            file(APPEND ${bat_file} "${arg} ")
+        endforeach(arg)
+        file(APPEND ${bat_file} "\n")
+
+        add_test(${test_name} ${bat_file})
+    endif(WIN32)
+
+endfunction(GR_ADD_TEST)
diff --git a/cmake/Modules/GrVersion.cmake b/cmake/Modules/GrVersion.cmake
new file mode 100644
index 0000000..bafd0a7
--- /dev/null
+++ b/cmake/Modules/GrVersion.cmake
@@ -0,0 +1,82 @@
+# Copyright 2011,2013 Free Software Foundation, Inc.
+#
+# This file is part of GNU Radio
+#
+# GNU Radio is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3, or (at your option)
+# any later version.
+#
+# GNU Radio is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GNU Radio; see the file COPYING.  If not, write to
+# the Free Software Foundation, Inc., 51 Franklin Street,
+# Boston, MA 02110-1301, USA.
+
+if(DEFINED __INCLUDED_GR_VERSION_CMAKE)
+    return()
+endif()
+set(__INCLUDED_GR_VERSION_CMAKE TRUE)
+
+#eventually, replace version.sh and fill in the variables below
+set(MAJOR_VERSION ${VERSION_INFO_MAJOR_VERSION})
+set(API_COMPAT    ${VERSION_INFO_API_COMPAT})
+set(MINOR_VERSION ${VERSION_INFO_MINOR_VERSION})
+set(MAINT_VERSION ${VERSION_INFO_MAINT_VERSION})
+
+########################################################################
+# Extract the version string from git describe.
+########################################################################
+find_package(Git)
+
+if(GIT_FOUND AND EXISTS ${CMAKE_SOURCE_DIR}/.git)
+    message(STATUS "Extracting version information from git describe...")
+    execute_process(
+        COMMAND ${GIT_EXECUTABLE} describe --always --abbrev=8 --long
+        OUTPUT_VARIABLE GIT_DESCRIBE OUTPUT_STRIP_TRAILING_WHITESPACE
+        WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}
+    )
+else()
+    set(GIT_DESCRIBE "v${MAJOR_VERSION}.${API_COMPAT}.x-xxx-xunknown")
+endif()
+
+########################################################################
+# Use the logic below to set the version constants
+########################################################################
+if("${MINOR_VERSION}" STREQUAL "git")
+    # VERSION: 3.3git-xxx-gxxxxxxxx
+    # DOCVER:  3.3git
+    # LIBVER:  3.3git
+    set(VERSION "${GIT_DESCRIBE}")
+    set(DOCVER  "${MAJOR_VERSION}.${API_COMPAT}${MINOR_VERSION}")
+    set(LIBVER  "${MAJOR_VERSION}.${API_COMPAT}${MINOR_VERSION}")
+    set(RC_MINOR_VERSION "0")
+    set(RC_MAINT_VERSION "0")
+elseif("${MAINT_VERSION}" STREQUAL "git")
+    # VERSION: 3.3.1git-xxx-gxxxxxxxx
+    # DOCVER:  3.3.1git
+    # LIBVER:  3.3.1git
+    set(VERSION "${GIT_DESCRIBE}")
+    set(DOCVER  "${MAJOR_VERSION}.${API_COMPAT}.${MINOR_VERSION}${MAINT_VERSION}")
+    set(LIBVER  "${MAJOR_VERSION}.${API_COMPAT}.${MINOR_VERSION}${MAINT_VERSION}")
+    math(EXPR RC_MINOR_VERSION "${MINOR_VERSION} - 1")
+    set(RC_MAINT_VERSION "0")
+else()
+    # This is a numbered release.
+    # VERSION: 3.3.1{.x}
+    # DOCVER:  3.3.1{.x}
+    # LIBVER:  3.3.1{.x}
+    if("${MAINT_VERSION}" STREQUAL "0")
+        set(VERSION "${MAJOR_VERSION}.${API_COMPAT}.${MINOR_VERSION}")
+    else()
+        set(VERSION "${MAJOR_VERSION}.${API_COMPAT}.${MINOR_VERSION}.${MAINT_VERSION}")
+    endif()
+    set(DOCVER "${VERSION}")
+    set(LIBVER "${VERSION}")
+    set(RC_MINOR_VERSION ${MINOR_VERSION})
+    set(RC_MAINT_VERSION ${MAINT_VERSION})
+endif()
diff --git a/grc/gen_osmosdr_blocks.py b/grc/gen_osmosdr_blocks.py
index e30cc70..a4a7f96 100644
--- a/grc/gen_osmosdr_blocks.py
+++ b/grc/gen_osmosdr_blocks.py
@@ -33,11 +33,11 @@ parameters:
   option_attributes:
       type: [fc32]
   hide: part
-- id: dev_args
+- id: args
   label: 'Device Arguments'
   dtype: string
   default: '""'
-  hide: ${'$'}{ 'none' if dev_args else 'part'}
+  hide: ${'$'}{ 'none' if args else 'part'}
 - id: sync
   label: Sync
   dtype: enum
@@ -137,7 +137,7 @@ templates:
   callbacks:
     - set_sample_rate(${'$'}{sample_rate})
     % for n in range(max_nchan):
-    - set_centre_freq(${'$'}{${'freq' + str(n)}}, ${n})
+    - set_center_freq(${'$'}{${'freq' + str(n)}}, ${n})
     - set_freq_corr(${'$'}{${'corr' + str(n)}}, ${n})
     % if sourk == 'source':
     - set_dc_offset_mode(${'$'}{${'dc_offset_mode' + str(n)}}, ${n})
diff --git a/include/osmosdr/CMakeLists.txt b/include/osmosdr/CMakeLists.txt
index 19ca3bc..d185ee6 100644
--- a/include/osmosdr/CMakeLists.txt
+++ b/include/osmosdr/CMakeLists.txt
@@ -1,7 +1,6 @@
-# Copyright 2011,2012 Free Software Foundation, Inc.
+# Copyright 2011 Free Software Foundation, Inc.
 #
-# This file was generated by gr_modtool, a tool from the GNU Radio framework
-# This file is a part of gr-osmosdr
+# This file is part of GNU Radio
 #
 # GNU Radio is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
@@ -23,6 +22,11 @@
 ########################################################################
 install(FILES
     api.h
+    pimpl.h
+    ranges.h
+    time_spec.h
+    device.h
     source.h
-    sink.h DESTINATION include/osmosdr
+    sink.h
+    DESTINATION include/osmosdr
 )
diff --git a/include/osmosdr/api.h b/include/osmosdr/api.h
index 43f2e28..d3adbf0 100644
--- a/include/osmosdr/api.h
+++ b/include/osmosdr/api.h
@@ -1,8 +1,7 @@
 /*
  * Copyright 2011 Free Software Foundation, Inc.
  *
- * This file was generated by gr_modtool, a tool from the GNU Radio framework
- * This file is a part of gr-osmosdr
+ * This file is part of GNU Radio
  *
  * GNU Radio is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
diff --git a/include/osmosdr/sink.h b/include/osmosdr/sink.h
index 85f41e2..906976e 100644
--- a/include/osmosdr/sink.h
+++ b/include/osmosdr/sink.h
@@ -1,23 +1,22 @@
 /* -*- c++ -*- */
 /*
- * Copyright 2019 gr-osmosdr author.
+ * Copyright 2012 Dimitri Stolnikov <horiz0n@gmx.net>
  *
- * This is free software; you can redistribute it and/or modify
+ * GNU Radio is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 3, or (at your option)
  * any later version.
  *
- * This software is distributed in the hope that it will be useful,
+ * GNU Radio is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this software; see the file COPYING.  If not, write to
+ * along with GNU Radio; see the file COPYING.  If not, write to
  * the Free Software Foundation, Inc., 51 Franklin Street,
  * Boston, MA 02110-1301, USA.
  */
-
 #ifndef INCLUDED_OSMOSDR_SINK_H
 #define INCLUDED_OSMOSDR_SINK_H
 
@@ -28,352 +27,352 @@
 
 namespace osmosdr {
 
-  class sink;
+class sink;
 
-  /*!
- * \brief <+description of block+>
- * \ingroup osmosdr
+/*!
+ * \brief Takes a stream of complex samples.
+ * \ingroup block
  *
+ * This uses the preferred technique: subclassing gr::hier_block2.
  */
 class OSMOSDR_API sink : virtual public gr::hier_block2
 {
- public:
-  typedef boost::shared_ptr<sink> sptr;
-
-    /*!
-      * \brief Return a shared_ptr to a new instance of sink.
-      *
-      * To avoid accidental use of raw pointers, sink's
-      * constructor is private.  osmosdr::sink::make is the public
-      * interface for creating new instances.
-      *
-      * \param args the address to identify the hardware
-      * \return a new osmosdr sink block object
-      */
-    static sptr make( const std::string & args = "" );
-
-    /*!
-     * Get the number of channels the underlying radio hardware offers.
-     * \return the number of available channels
-     */
-    virtual size_t get_num_channels( void ) = 0;
-
-    /*!
-     * Get the possible sample rates for the underlying radio hardware.
-     * \return a range of rates in Sps
-     */
-    virtual osmosdr::meta_range_t get_sample_rates( void ) = 0;
-
-    /*!
-     * Set the sample rate for the underlying radio hardware.
-     * This also will select the appropriate IF bandpass, if applicable.
-     * \param rate a new rate in Sps
-     */
-    virtual double set_sample_rate( double rate ) = 0;
-
-    /*!
-     * Get the sample rate for the underlying radio hardware.
-     * This is the actual sample rate and may differ from the rate set.
-     * \return the actual rate in Sps
-     */
-    virtual double get_sample_rate( void ) = 0;
-
-    /*!
-     * Get the tunable frequency range for the underlying radio hardware.
-     * \param chan the channel index 0 to N-1
-     * \return the frequency range in Hz
-     */
-    virtual osmosdr::freq_range_t get_freq_range( size_t chan = 0 ) = 0;
-
-    /*!
-     * Tune the underlying radio hardware to the desired center frequency.
-     * This also will select the appropriate RF bandpass.
-     * \param freq the desired frequency in Hz
-     * \param chan the channel index 0 to N-1
-     * \return the actual frequency in Hz
-     */
-    virtual double set_center_freq( double freq, size_t chan = 0 ) = 0;
-
-    /*!
-     * Get the center frequency the underlying radio hardware is tuned to.
-     * This is the actual frequency and may differ from the frequency set.
-     * \param chan the channel index 0 to N-1
-     * \return the frequency in Hz
-     */
-    virtual double get_center_freq( size_t chan = 0 ) = 0;
-
-    /*!
-     * Set the frequency correction value in parts per million.
-     * \param ppm the desired correction value in parts per million
-     * \param chan the channel index 0 to N-1
-     * \return correction value in parts per million
-     */
-    virtual double set_freq_corr( double ppm, size_t chan = 0 ) = 0;
-
-    /*!
-     * Get the frequency correction value.
-     * \param chan the channel index 0 to N-1
-     * \return correction value in parts per million
-     */
-    virtual double get_freq_corr( size_t chan = 0 ) = 0;
-
-    /*!
-     * Get the gain stage names of the underlying radio hardware.
-     * \param chan the channel index 0 to N-1
-     * \return a vector of strings containing the names of gain stages
-     */
-    virtual std::vector<std::string> get_gain_names( size_t chan = 0 ) = 0;
-
-    /*!
-     * Get the settable overall gain range for the underlying radio hardware.
-     * \param chan the channel index 0 to N-1
-     * \return the gain range in dB
-     */
-    virtual osmosdr::gain_range_t get_gain_range( size_t chan = 0 ) = 0;
-
-    /*!
-     * Get the settable gain range for a specific gain stage.
-     * \param name the name of the gain stage
-     * \param chan the channel index 0 to N-1
-     * \return the gain range in dB
-     */
-    virtual osmosdr::gain_range_t get_gain_range( const std::string & name,
-                                                  size_t chan = 0 ) = 0;
-
-    /*!
-     * Set the gain mode for the underlying radio hardware.
-     * This might be supported only for certain hardware types.
-     * \param automatic the gain mode (true means automatic gain mode)
-     * \param chan the channel index 0 to N-1
-     * \return the actual gain mode
-     */
-    virtual bool set_gain_mode( bool automatic, size_t chan = 0 ) = 0;
-
-    /*!
-     * Get the gain mode selected for the underlying radio hardware.
-     * \param chan the channel index 0 to N-1
-     * \return the actual gain mode (true means automatic gain mode)
-     */
-    virtual bool get_gain_mode( size_t chan = 0 ) = 0;
-
-    /*!
-     * Set the gain for the underlying radio hardware.
-     * This function will automatically distribute the desired gain value over
-     * available gain stages in an appropriate way and return the actual value.
-     * \param gain the gain in dB
-     * \param chan the channel index 0 to N-1
-     * \return the actual gain in dB
-     */
-    virtual double set_gain( double gain, size_t chan = 0 ) = 0;
-
-    /*!
-     * Set the named gain on the underlying radio hardware.
-     * \param gain the gain in dB
-     * \param name the name of the gain stage
-     * \param chan the channel index 0 to N-1
-     * \return the actual gain in dB
-     */
-    virtual double set_gain( double gain,
-                             const std::string & name,
-                             size_t chan = 0 ) = 0;
-
-    /*!
-     * Get the actual gain setting of the underlying radio hardware.
-     * \param chan the channel index 0 to N-1
-     * \return the actual gain in dB
-     */
-    virtual double get_gain( size_t chan = 0 ) = 0;
-
-    /*!
-     * Get the actual gain setting of a named stage.
-     * \param name the name of the gain stage
-     * \param chan the channel index 0 to N-1
-     * \return the actual gain in dB
-     */
-    virtual double get_gain( const std::string & name, size_t chan = 0 ) = 0;
-
-    /*!
-     * Set the IF gain for the underlying radio hardware.
-     * This function will automatically distribute the desired gain value over
-     * available IF gain stages in an appropriate way and return the actual value.
-     * \param gain the gain in dB
-     * \param chan the channel index 0 to N-1
-     * \return the actual gain in dB
-     */
-    virtual double set_if_gain( double gain, size_t chan = 0 ) = 0;
-
-    /*!
-     * Set the BB gain for the underlying radio hardware.
-     * This function will automatically distribute the desired gain value over
-     * available BB gain stages in an appropriate way and return the actual value.
-     * \param gain the gain in dB
-     * \param chan the channel index 0 to N-1
-     * \return the actual gain in dB
-     */
-    virtual double set_bb_gain( double gain, size_t chan = 0 ) = 0;
-
-    /*!
-     * Get the available antennas of the underlying radio hardware.
-     * \param chan the channel index 0 to N-1
-     * \return a vector of strings containing the names of available antennas
-     */
-    virtual std::vector< std::string > get_antennas( size_t chan = 0 ) = 0;
-
-    /*!
-     * Select the active antenna of the underlying radio hardware.
-     * \param antenna name of the antenna to be selected
-     * \param chan the channel index 0 to N-1
-     * \return the actual antenna's name
-     */
-    virtual std::string set_antenna( const std::string & antenna,
-                                     size_t chan = 0 ) = 0;
-
-    /*!
-     * Get the actual underlying radio hardware antenna setting.
-     * \param chan the channel index 0 to N-1
-     * \return the actual antenna's name
-     */
-    virtual std::string get_antenna( size_t chan = 0 ) = 0;
-
-    /*!
-     * Set the TX frontend DC offset value.
-     * The value is complex to control both I and Q.
-     *
-     * \param offset the dc offset (1.0 is full-scale)
-     * \param chan the channel index 0 to N-1
-     */
-    virtual void set_dc_offset( const std::complex<double> &offset, size_t chan = 0 ) = 0;
-
-    /*!
-     * Set the TX frontend IQ balance correction.
-     * Use this to adjust the magnitude and phase of I and Q.
-     *
-     * \param balance the complex correction value
-     * \param chan the channel index 0 to N-1
-     */
-    virtual void set_iq_balance( const std::complex<double> &balance, size_t chan = 0 ) = 0;
-
-    /*!
-     * Set the bandpass filter on the radio frontend.
-     * \param bandwidth the filter bandwidth in Hz, set to 0 for automatic selection
-     * \param chan the channel index 0 to N-1
-     * \return the actual filter bandwidth in Hz
-     */
-    virtual double set_bandwidth( double bandwidth, size_t chan = 0 ) = 0;
-
-    /*!
-     * Get the actual bandpass filter setting on the radio frontend.
-     * \param chan the channel index 0 to N-1
-     * \return the actual filter bandwidth in Hz
-     */
-    virtual double get_bandwidth( size_t chan = 0 ) = 0;
-
-    /*!
-     * Get the possible bandpass filter settings on the radio frontend.
-     * \param chan the channel index 0 to N-1
-     * \return a range of bandwidths in Hz
-     */
-    virtual osmosdr::freq_range_t get_bandwidth_range( size_t chan = 0 ) = 0;
-
-    /*!
-     * Set the time source for the device.
-     * This sets the method of time synchronization,
-     * typically a pulse per second or an encoded time.
-     * Typical options for source: external, MIMO.
-     * \param source a string representing the time source
-     * \param mboard which motherboard to set the config
-     */
-    virtual void set_time_source(const std::string &source,
-                                 const size_t mboard = 0) = 0;
-
-    /*!
-     * Get the currently set time source.
-     * \param mboard which motherboard to get the config
-     * \return the string representing the time source
-     */
-    virtual std::string get_time_source(const size_t mboard) = 0;
-
-    /*!
-     * Get a list of possible time sources.
-     * \param mboard which motherboard to get the list
-     * \return a vector of strings for possible settings
-     */
-    virtual std::vector<std::string> get_time_sources(const size_t mboard) = 0;
-
-    /*!
-     * Set the clock source for the device.
-     * This sets the source for a 10 Mhz reference clock.
-     * Typical options for source: internal, external, MIMO.
-     * \param source a string representing the clock source
-     * \param mboard which motherboard to set the config
-     */
-    virtual void set_clock_source(const std::string &source,
-                                  const size_t mboard = 0) = 0;
-
-    /*!
-     * Get the currently set clock source.
-     * \param mboard which motherboard to get the config
-     * \return the string representing the clock source
-     */
-    virtual std::string get_clock_source(const size_t mboard) = 0;
-
-    /*!
-     * Get a list of possible clock sources.
-     * \param mboard which motherboard to get the list
-     * \return a vector of strings for possible settings
-     */
-    virtual std::vector<std::string> get_clock_sources(const size_t mboard) = 0;
-
-    /*!
-     * Get the master clock rate.
-     * \param mboard the motherboard index 0 to M-1
-     * \return the clock rate in Hz
-     */
-    virtual double get_clock_rate(size_t mboard = 0) = 0;
-
-    /*!
-     * Set the master clock rate.
-     * \param rate the new rate in Hz
-     * \param mboard the motherboard index 0 to M-1
-     */
-    virtual void set_clock_rate(double rate, size_t mboard = 0) = 0;
-
-    /*!
-     * Get the current time registers.
-     * \param mboard the motherboard index 0 to M-1
-     * \return the current device time
-     */
-    virtual ::osmosdr::time_spec_t get_time_now(size_t mboard = 0) = 0;
-
-    /*!
-     * Get the time when the last pps pulse occured.
-     * \param mboard the motherboard index 0 to M-1
-     * \return the current device time
-     */
-    virtual ::osmosdr::time_spec_t get_time_last_pps(size_t mboard = 0) = 0;
-
-    /*!
-     * Sets the time registers immediately.
-     * \param time_spec the new time
-     * \param mboard the motherboard index 0 to M-1
-     */
-    virtual void set_time_now(const ::osmosdr::time_spec_t &time_spec,
-                              size_t mboard = 0) = 0;
-
-    /*!
-     * Set the time registers at the next pps.
-     * \param time_spec the new time
-     */
-    virtual void set_time_next_pps(const ::osmosdr::time_spec_t &time_spec) = 0;
-
-    /*!
-     * Sync the time registers with an unknown pps edge.
-     * \param time_spec the new time
-     */
-    virtual void set_time_unknown_pps(const ::osmosdr::time_spec_t &time_spec) = 0;
+public:
+  typedef boost::shared_ptr< sink > sptr;
+
+  /*!
+   * \brief Return a shared_ptr to a new instance of sink.
+   *
+   * To avoid accidental use of raw pointers, sink's
+   * constructor is private.  osmosdr::sink::make is the public
+   * interface for creating new instances.
+   *
+   * \param args the address to identify the hardware
+   * \return a new osmosdr sink block object
+   */
+  static sptr make( const std::string & args = "" );
+
+  /*!
+   * Get the number of channels the underlying radio hardware offers.
+   * \return the number of available channels
+   */
+  virtual size_t get_num_channels( void ) = 0;
+
+  /*!
+   * Get the possible sample rates for the underlying radio hardware.
+   * \return a range of rates in Sps
+   */
+  virtual osmosdr::meta_range_t get_sample_rates( void ) = 0;
+
+  /*!
+   * Set the sample rate for the underlying radio hardware.
+   * This also will select the appropriate IF bandpass, if applicable.
+   * \param rate a new rate in Sps
+   */
+  virtual double set_sample_rate( double rate ) = 0;
+
+  /*!
+   * Get the sample rate for the underlying radio hardware.
+   * This is the actual sample rate and may differ from the rate set.
+   * \return the actual rate in Sps
+   */
+  virtual double get_sample_rate( void ) = 0;
+
+  /*!
+   * Get the tunable frequency range for the underlying radio hardware.
+   * \param chan the channel index 0 to N-1
+   * \return the frequency range in Hz
+   */
+  virtual osmosdr::freq_range_t get_freq_range( size_t chan = 0 ) = 0;
+
+  /*!
+   * Tune the underlying radio hardware to the desired center frequency.
+   * This also will select the appropriate RF bandpass.
+   * \param freq the desired frequency in Hz
+   * \param chan the channel index 0 to N-1
+   * \return the actual frequency in Hz
+   */
+  virtual double set_center_freq( double freq, size_t chan = 0 ) = 0;
+
+  /*!
+   * Get the center frequency the underlying radio hardware is tuned to.
+   * This is the actual frequency and may differ from the frequency set.
+   * \param chan the channel index 0 to N-1
+   * \return the frequency in Hz
+   */
+  virtual double get_center_freq( size_t chan = 0 ) = 0;
+
+  /*!
+   * Set the frequency correction value in parts per million.
+   * \param ppm the desired correction value in parts per million
+   * \param chan the channel index 0 to N-1
+   * \return correction value in parts per million
+   */
+  virtual double set_freq_corr( double ppm, size_t chan = 0 ) = 0;
+
+  /*!
+   * Get the frequency correction value.
+   * \param chan the channel index 0 to N-1
+   * \return correction value in parts per million
+   */
+  virtual double get_freq_corr( size_t chan = 0 ) = 0;
+
+  /*!
+   * Get the gain stage names of the underlying radio hardware.
+   * \param chan the channel index 0 to N-1
+   * \return a vector of strings containing the names of gain stages
+   */
+  virtual std::vector<std::string> get_gain_names( size_t chan = 0 ) = 0;
+
+  /*!
+   * Get the settable overall gain range for the underlying radio hardware.
+   * \param chan the channel index 0 to N-1
+   * \return the gain range in dB
+   */
+  virtual osmosdr::gain_range_t get_gain_range( size_t chan = 0 ) = 0;
+
+  /*!
+   * Get the settable gain range for a specific gain stage.
+   * \param name the name of the gain stage
+   * \param chan the channel index 0 to N-1
+   * \return the gain range in dB
+   */
+  virtual osmosdr::gain_range_t get_gain_range( const std::string & name,
+                                                size_t chan = 0 ) = 0;
+
+  /*!
+   * Set the gain mode for the underlying radio hardware.
+   * This might be supported only for certain hardware types.
+   * \param automatic the gain mode (true means automatic gain mode)
+   * \param chan the channel index 0 to N-1
+   * \return the actual gain mode
+   */
+  virtual bool set_gain_mode( bool automatic, size_t chan = 0 ) = 0;
+
+  /*!
+   * Get the gain mode selected for the underlying radio hardware.
+   * \param chan the channel index 0 to N-1
+   * \return the actual gain mode (true means automatic gain mode)
+   */
+  virtual bool get_gain_mode( size_t chan = 0 ) = 0;
+
+  /*!
+   * Set the gain for the underlying radio hardware.
+   * This function will automatically distribute the desired gain value over
+   * available gain stages in an appropriate way and return the actual value.
+   * \param gain the gain in dB
+   * \param chan the channel index 0 to N-1
+   * \return the actual gain in dB
+   */
+  virtual double set_gain( double gain, size_t chan = 0 ) = 0;
+
+  /*!
+   * Set the named gain on the underlying radio hardware.
+   * \param gain the gain in dB
+   * \param name the name of the gain stage
+   * \param chan the channel index 0 to N-1
+   * \return the actual gain in dB
+   */
+  virtual double set_gain( double gain,
+                           const std::string & name,
+                           size_t chan = 0 ) = 0;
+
+  /*!
+   * Get the actual gain setting of the underlying radio hardware.
+   * \param chan the channel index 0 to N-1
+   * \return the actual gain in dB
+   */
+  virtual double get_gain( size_t chan = 0 ) = 0;
+
+  /*!
+   * Get the actual gain setting of a named stage.
+   * \param name the name of the gain stage
+   * \param chan the channel index 0 to N-1
+   * \return the actual gain in dB
+   */
+  virtual double get_gain( const std::string & name, size_t chan = 0 ) = 0;
+
+  /*!
+   * Set the IF gain for the underlying radio hardware.
+   * This function will automatically distribute the desired gain value over
+   * available IF gain stages in an appropriate way and return the actual value.
+   * \param gain the gain in dB
+   * \param chan the channel index 0 to N-1
+   * \return the actual gain in dB
+   */
+  virtual double set_if_gain( double gain, size_t chan = 0 ) = 0;
+
+  /*!
+   * Set the BB gain for the underlying radio hardware.
+   * This function will automatically distribute the desired gain value over
+   * available BB gain stages in an appropriate way and return the actual value.
+   * \param gain the gain in dB
+   * \param chan the channel index 0 to N-1
+   * \return the actual gain in dB
+   */
+  virtual double set_bb_gain( double gain, size_t chan = 0 ) = 0;
+
+  /*!
+   * Get the available antennas of the underlying radio hardware.
+   * \param chan the channel index 0 to N-1
+   * \return a vector of strings containing the names of available antennas
+   */
+  virtual std::vector< std::string > get_antennas( size_t chan = 0 ) = 0;
+
+  /*!
+   * Select the active antenna of the underlying radio hardware.
+   * \param antenna name of the antenna to be selected
+   * \param chan the channel index 0 to N-1
+   * \return the actual antenna's name
+   */
+  virtual std::string set_antenna( const std::string & antenna,
+                                   size_t chan = 0 ) = 0;
+
+  /*!
+   * Get the actual underlying radio hardware antenna setting.
+   * \param chan the channel index 0 to N-1
+   * \return the actual antenna's name
+   */
+  virtual std::string get_antenna( size_t chan = 0 ) = 0;
+
+  /*!
+   * Set the TX frontend DC offset value.
+   * The value is complex to control both I and Q.
+   *
+   * \param offset the dc offset (1.0 is full-scale)
+   * \param chan the channel index 0 to N-1
+   */
+  virtual void set_dc_offset( const std::complex<double> &offset, size_t chan = 0 ) = 0;
+
+  /*!
+   * Set the TX frontend IQ balance correction.
+   * Use this to adjust the magnitude and phase of I and Q.
+   *
+   * \param balance the complex correction value
+   * \param chan the channel index 0 to N-1
+   */
+  virtual void set_iq_balance( const std::complex<double> &balance, size_t chan = 0 ) = 0;
+
+  /*!
+   * Set the bandpass filter on the radio frontend.
+   * \param bandwidth the filter bandwidth in Hz, set to 0 for automatic selection
+   * \param chan the channel index 0 to N-1
+   * \return the actual filter bandwidth in Hz
+   */
+  virtual double set_bandwidth( double bandwidth, size_t chan = 0 ) = 0;
+
+  /*!
+   * Get the actual bandpass filter setting on the radio frontend.
+   * \param chan the channel index 0 to N-1
+   * \return the actual filter bandwidth in Hz
+   */
+  virtual double get_bandwidth( size_t chan = 0 ) = 0;
+
+  /*!
+   * Get the possible bandpass filter settings on the radio frontend.
+   * \param chan the channel index 0 to N-1
+   * \return a range of bandwidths in Hz
+   */
+  virtual osmosdr::freq_range_t get_bandwidth_range( size_t chan = 0 ) = 0;
+
+  /*!
+   * Set the time source for the device.
+   * This sets the method of time synchronization,
+   * typically a pulse per second or an encoded time.
+   * Typical options for source: external, MIMO.
+   * \param source a string representing the time source
+   * \param mboard which motherboard to set the config
+   */
+  virtual void set_time_source(const std::string &source,
+                               const size_t mboard = 0) = 0;
+
+  /*!
+   * Get the currently set time source.
+   * \param mboard which motherboard to get the config
+   * \return the string representing the time source
+   */
+  virtual std::string get_time_source(const size_t mboard) = 0;
+
+  /*!
+   * Get a list of possible time sources.
+   * \param mboard which motherboard to get the list
+   * \return a vector of strings for possible settings
+   */
+  virtual std::vector<std::string> get_time_sources(const size_t mboard) = 0;
+
+  /*!
+   * Set the clock source for the device.
+   * This sets the source for a 10 Mhz reference clock.
+   * Typical options for source: internal, external, MIMO.
+   * \param source a string representing the clock source
+   * \param mboard which motherboard to set the config
+   */
+  virtual void set_clock_source(const std::string &source,
+                                const size_t mboard = 0) = 0;
+
+  /*!
+   * Get the currently set clock source.
+   * \param mboard which motherboard to get the config
+   * \return the string representing the clock source
+   */
+  virtual std::string get_clock_source(const size_t mboard) = 0;
+
+  /*!
+   * Get a list of possible clock sources.
+   * \param mboard which motherboard to get the list
+   * \return a vector of strings for possible settings
+   */
+  virtual std::vector<std::string> get_clock_sources(const size_t mboard) = 0;
+
+  /*!
+   * Get the master clock rate.
+   * \param mboard the motherboard index 0 to M-1
+   * \return the clock rate in Hz
+   */
+  virtual double get_clock_rate(size_t mboard = 0) = 0;
+
+  /*!
+   * Set the master clock rate.
+   * \param rate the new rate in Hz
+   * \param mboard the motherboard index 0 to M-1
+   */
+  virtual void set_clock_rate(double rate, size_t mboard = 0) = 0;
+
+  /*!
+   * Get the current time registers.
+   * \param mboard the motherboard index 0 to M-1
+   * \return the current device time
+   */
+  virtual ::osmosdr::time_spec_t get_time_now(size_t mboard = 0) = 0;
+
+  /*!
+   * Get the time when the last pps pulse occured.
+   * \param mboard the motherboard index 0 to M-1
+   * \return the current device time
+   */
+  virtual ::osmosdr::time_spec_t get_time_last_pps(size_t mboard = 0) = 0;
+
+  /*!
+   * Sets the time registers immediately.
+   * \param time_spec the new time
+   * \param mboard the motherboard index 0 to M-1
+   */
+  virtual void set_time_now(const ::osmosdr::time_spec_t &time_spec,
+                            size_t mboard = 0) = 0;
+
+  /*!
+   * Set the time registers at the next pps.
+   * \param time_spec the new time
+   */
+  virtual void set_time_next_pps(const ::osmosdr::time_spec_t &time_spec) = 0;
+
+  /*!
+   * Sync the time registers with an unknown pps edge.
+   * \param time_spec the new time
+   */
+  virtual void set_time_unknown_pps(const ::osmosdr::time_spec_t &time_spec) = 0;
 };
 
-} // namespace osmosdr
+} /* namespace osmosdr */
 
 #endif /* INCLUDED_OSMOSDR_SINK_H */
-
diff --git a/include/osmosdr/source.h b/include/osmosdr/source.h
index c83c2fd..88f8385 100644
--- a/include/osmosdr/source.h
+++ b/include/osmosdr/source.h
@@ -1,23 +1,22 @@
 /* -*- c++ -*- */
 /*
- * Copyright 2019 gr-osmosdr author.
+ * Copyright 2012 Dimitri Stolnikov <horiz0n@gmx.net>
  *
- * This is free software; you can redistribute it and/or modify
+ * GNU Radio is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 3, or (at your option)
  * any later version.
  *
- * This software is distributed in the hope that it will be useful,
+ * GNU Radio is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this software; see the file COPYING.  If not, write to
+ * along with GNU Radio; see the file COPYING.  If not, write to
  * the Free Software Foundation, Inc., 51 Franklin Street,
  * Boston, MA 02110-1301, USA.
  */
-
 #ifndef INCLUDED_OSMOSDR_SOURCE_H
 #define INCLUDED_OSMOSDR_SOURCE_H
 
@@ -30,17 +29,18 @@ namespace osmosdr {
 
 class source;
 
-    /*!
- * \brief <+description of block+>
- * \ingroup osmosdr
+/*!
+ * \brief Provides a stream of complex samples.
+ * \ingroup block
  *
+ * This uses the preferred technique: subclassing gr::hier_block2.
  */
 class OSMOSDR_API source : virtual public gr::hier_block2
 {
- public:
-  typedef boost::shared_ptr<source> sptr;
+public:
+  typedef boost::shared_ptr< source > sptr;
 
-/*!
+  /*!
    * \brief Return a shared_ptr to a new instance of source.
    *
    * To avoid accidental use of raw pointers, source's
@@ -50,374 +50,373 @@ class OSMOSDR_API source : virtual public gr::hier_block2
    * \param args the address to identify the hardware
    * \return a new osmosdr source block object
    */
-    static sptr make( const std::string & args = "" );
-
-    /*!
-     * Get the number of channels the underlying radio hardware offers.
-     * \return the number of available channels
-     */
-    virtual size_t get_num_channels( void ) = 0;
-
-    /*!
-     * \brief seek file to \p seek_point relative to \p whence
-     *
-     * \param seek_point	sample offset in file
-     * \param whence	one of SEEK_SET, SEEK_CUR, SEEK_END (man fseek)
-     * \return true on success
-     */
-    virtual bool seek( long seek_point, int whence, size_t chan = 0 ) = 0;
-
-    /*!
-     * Get the possible sample rates for the underlying radio hardware.
-     * \return a range of rates in Sps
-     */
-    virtual osmosdr::meta_range_t get_sample_rates( void ) = 0;
-
-    /*!
-     * Set the sample rate for the underlying radio hardware.
-     * This also will select the appropriate IF bandpass, if applicable.
-     * \param rate a new rate in Sps
-     */
-    virtual double set_sample_rate( double rate ) = 0;
-
-    /*!
-     * Get the sample rate for the underlying radio hardware.
-     * This is the actual sample rate and may differ from the rate set.
-     * \return the actual rate in Sps
-     */
-    virtual double get_sample_rate( void ) = 0;
-
-    /*!
-     * Get the tunable frequency range for the underlying radio hardware.
-     * \param chan the channel index 0 to N-1
-     * \return the frequency range in Hz
-     */
-    virtual osmosdr::freq_range_t get_freq_range( size_t chan = 0 ) = 0;
-
-    /*!
-     * Tune the underlying radio hardware to the desired center frequency.
-     * This also will select the appropriate RF bandpass.
-     * \param freq the desired frequency in Hz
-     * \param chan the channel index 0 to N-1
-     * \return the actual frequency in Hz
-     */
-    virtual double set_center_freq( double freq, size_t chan = 0 ) = 0;
-
-    /*!
-     * Get the center frequency the underlying radio hardware is tuned to.
-     * This is the actual frequency and may differ from the frequency set.
-     * \param chan the channel index 0 to N-1
-     * \return the frequency in Hz
-     */
-    virtual double get_center_freq( size_t chan = 0 ) = 0;
-
-    /*!
-     * Set the frequency correction value in parts per million.
-     * \param ppm the desired correction value in parts per million
-     * \param chan the channel index 0 to N-1
-     * \return correction value in parts per million
-     */
-    virtual double set_freq_corr( double ppm, size_t chan = 0 ) = 0;
-
-    /*!
-     * Get the frequency correction value.
-     * \param chan the channel index 0 to N-1
-     * \return correction value in parts per million
-     */
-    virtual double get_freq_corr( size_t chan = 0 ) = 0;
-
-    /*!
-     * Get the gain stage names of the underlying radio hardware.
-     * \param chan the channel index 0 to N-1
-     * \return a vector of strings containing the names of gain stages
-     */
-    virtual std::vector<std::string> get_gain_names( size_t chan = 0 ) = 0;
-
-    /*!
-     * Get the settable overall gain range for the underlying radio hardware.
-     * \param chan the channel index 0 to N-1
-     * \return the gain range in dB
-     */
-    virtual osmosdr::gain_range_t get_gain_range( size_t chan = 0 ) = 0;
-
-    /*!
-     * Get the settable gain range for a specific gain stage.
-     * \param name the name of the gain stage
-     * \param chan the channel index 0 to N-1
-     * \return the gain range in dB
-     */
-    virtual osmosdr::gain_range_t get_gain_range( const std::string & name,
-                                                  size_t chan = 0 ) = 0;
-
-    /*!
-     * Set the gain mode for the underlying radio hardware.
-     * This might be supported only for certain hardware types.
-     * \param automatic the gain mode (true means automatic gain mode)
-     * \param chan the channel index 0 to N-1
-     * \return the actual gain mode
-     */
-    virtual bool set_gain_mode( bool automatic, size_t chan = 0 ) = 0;
-
-    /*!
-     * Get the gain mode selected for the underlying radio hardware.
-     * \param chan the channel index 0 to N-1
-     * \return the actual gain mode (true means automatic gain mode)
-     */
-    virtual bool get_gain_mode( size_t chan = 0 ) = 0;
-
-    /*!
-     * Set the gain for the underlying radio hardware.
-     * This function will automatically distribute the desired gain value over
-     * available gain stages in an appropriate way and return the actual value.
-     * \param gain the gain in dB
-     * \param chan the channel index 0 to N-1
-     * \return the actual gain in dB
-     */
-    virtual double set_gain( double gain, size_t chan = 0 ) = 0;
-
-    /*!
-     * Set the named gain on the underlying radio hardware.
-     * \param gain the gain in dB
-     * \param name the name of the gain stage
-     * \param chan the channel index 0 to N-1
-     * \return the actual gain in dB
-     */
-    virtual double set_gain( double gain,
-                             const std::string & name,
-                             size_t chan = 0 ) = 0;
-
-    /*!
-     * Get the actual gain setting of the underlying radio hardware.
-     * \param chan the channel index 0 to N-1
-     * \return the actual gain in dB
-     */
-    virtual double get_gain( size_t chan = 0 ) = 0;
-
-    /*!
-     * Get the actual gain setting of a named stage.
-     * \param name the name of the gain stage
-     * \param chan the channel index 0 to N-1
-     * \return the actual gain in dB
-     */
-    virtual double get_gain( const std::string & name, size_t chan = 0 ) = 0;
-
-    /*!
-     * Set the IF gain for the underlying radio hardware.
-     * This function will automatically distribute the desired gain value over
-     * available IF gain stages in an appropriate way and return the actual value.
-     * \param gain the gain in dB
-     * \param chan the channel index 0 to N-1
-     * \return the actual gain in dB
-     */
-    virtual double set_if_gain( double gain, size_t chan = 0 ) = 0;
-
-    /*!
-     * Set the BB gain for the underlying radio hardware.
-     * This function will automatically distribute the desired gain value over
-     * available BB gain stages in an appropriate way and return the actual value.
-     * \param gain the gain in dB
-     * \param chan the channel index 0 to N-1
-     * \return the actual gain in dB
-     */
-    virtual double set_bb_gain( double gain, size_t chan = 0 ) = 0;
-
-    /*!
-     * Get the available antennas of the underlying radio hardware.
-     * \param chan the channel index 0 to N-1
-     * \return a vector of strings containing the names of available antennas
-     */
-    virtual std::vector< std::string > get_antennas( size_t chan = 0 ) = 0;
-
-    /*!
-     * Select the active antenna of the underlying radio hardware.
-     * \param antenna name of the antenna to be selected
-     * \param chan the channel index 0 to N-1
-     * \return the actual antenna's name
-     */
-    virtual std::string set_antenna( const std::string & antenna,
-                                     size_t chan = 0 ) = 0;
-
-    /*!
-     * Get the actual underlying radio hardware antenna setting.
-     * \param chan the channel index 0 to N-1
-     * \return the actual antenna's name
-     */
-    virtual std::string get_antenna( size_t chan = 0 ) = 0;
-
-    enum DCOffsetMode {
-        DCOffsetOff = 0,
-        DCOffsetManual,
-        DCOffsetAutomatic
-    };
-
-    /*!
-     * Set the RX frontend DC correction mode.
-     * The automatic correction subtracts out the long-run average.
-     *
-     * When disabled, the averaging option operation is reset.
-     * Once in Manual mode, the average value will be held constant until
-     * the user re-enables the automatic correction or overrides the
-     * value by manually setting the offset.
-     *
-     * \param mode dc offset correction mode: 0 = Off, 1 = Manual, 2 = Automatic
-     * \param chan the channel index 0 to N-1
-     */
-    virtual void set_dc_offset_mode( int mode, size_t chan = 0) = 0;
-
-    /*!
-     * Set the RX frontend DC offset value.
-     * The value is complex to control both I and Q.
-     * Only set this when automatic correction is disabled.
-     *
-     * \param offset the dc offset (1.0 is full-scale)
-     * \param chan the channel index 0 to N-1
-     */
-    virtual void set_dc_offset( const std::complex<double> &offset, size_t chan = 0 ) = 0;
-
-    enum IQBalanceMode {
-        IQBalanceOff = 0,
-        IQBalanceManual,
-        IQBalanceAutomatic
-    };
-
-    /*!
-     * Set the RX frontend IQ balance mode.
-     *
-     * \param mode iq balance correction mode: 0 = Off, 1 = Manual, 2 = Automatic
-     * \param chan the channel index 0 to N-1
-     */
-    virtual void set_iq_balance_mode( int mode, size_t chan = 0 ) = 0;
-
-    /*!
-     * Set the RX frontend IQ balance correction.
-     * Use this to adjust the magnitude and phase of I and Q.
-     *
-     * \param balance the complex correction value
-     * \param chan the channel index 0 to N-1
-     */
-    virtual void set_iq_balance( const std::complex<double> &balance, size_t chan = 0 ) = 0;
-
-    /*!
-     * Set the bandpass filter on the radio frontend.
-     * \param bandwidth the filter bandwidth in Hz, set to 0 for automatic selection
-     * \param chan the channel index 0 to N-1
-     * \return the actual filter bandwidth in Hz
-     */
-    virtual double set_bandwidth( double bandwidth, size_t chan = 0 ) = 0;
-
-    /*!
-     * Get the actual bandpass filter setting on the radio frontend.
-     * \param chan the channel index 0 to N-1
-     * \return the actual filter bandwidth in Hz
-     */
-    virtual double get_bandwidth( size_t chan = 0 ) = 0;
-
-    /*!
-     * Get the possible bandpass filter settings on the radio frontend.
-     * \param chan the channel index 0 to N-1
-     * \return a range of bandwidths in Hz
-     */
-    virtual osmosdr::freq_range_t get_bandwidth_range( size_t chan = 0 ) = 0;
-
-    /*!
-     * Set the time source for the device.
-     * This sets the method of time synchronization,
-     * typically a pulse per second or an encoded time.
-     * Typical options for source: external, MIMO.
-     * \param source a string representing the time source
-     * \param mboard which motherboard to set the config
-     */
-    virtual void set_time_source(const std::string &source,
-                                 const size_t mboard = 0) = 0;
-
-    /*!
-     * Get the currently set time source.
-     * \param mboard which motherboard to get the config
-     * \return the string representing the time source
-     */
-    virtual std::string get_time_source(const size_t mboard) = 0;
-
-    /*!
-     * Get a list of possible time sources.
-     * \param mboard which motherboard to get the list
-     * \return a vector of strings for possible settings
-     */
-    virtual std::vector<std::string> get_time_sources(const size_t mboard) = 0;
-
-    /*!
-     * Set the clock source for the device.
-     * This sets the source for a 10 Mhz reference clock.
-     * Typical options for source: internal, external, MIMO.
-     * \param source a string representing the clock source
-     * \param mboard which motherboard to set the config
-     */
-    virtual void set_clock_source(const std::string &source,
-                                  const size_t mboard = 0) = 0;
-
-    /*!
-     * Get the currently set clock source.
-     * \param mboard which motherboard to get the config
-     * \return the string representing the clock source
-     */
-    virtual std::string get_clock_source(const size_t mboard) = 0;
-
-    /*!
-     * Get a list of possible clock sources.
-     * \param mboard which motherboard to get the list
-     * \return a vector of strings for possible settings
-     */
-    virtual std::vector<std::string> get_clock_sources(const size_t mboard) = 0;
-
-    /*!
-     * Get the master clock rate.
-     * \param mboard the motherboard index 0 to M-1
-     * \return the clock rate in Hz
-     */
-    virtual double get_clock_rate(size_t mboard = 0) = 0;
-
-    /*!
-     * Set the master clock rate.
-     * \param rate the new rate in Hz
-     * \param mboard the motherboard index 0 to M-1
-     */
-    virtual void set_clock_rate(double rate, size_t mboard = 0) = 0;
-
-    /*!
-     * Get the current time registers.
-     * \param mboard the motherboard index 0 to M-1
-     * \return the current device time
-     */
-    virtual ::osmosdr::time_spec_t get_time_now(size_t mboard = 0) = 0;
-
-    /*!
-     * Get the time when the last pps pulse occured.
-     * \param mboard the motherboard index 0 to M-1
-     * \return the current device time
-     */
-    virtual ::osmosdr::time_spec_t get_time_last_pps(size_t mboard = 0) = 0;
-
-    /*!
-     * Sets the time registers immediately.
-     * \param time_spec the new time
-     * \param mboard the motherboard index 0 to M-1
-     */
-    virtual void set_time_now(const ::osmosdr::time_spec_t &time_spec,
-                              size_t mboard = 0) = 0;
-
-    /*!
-     * Set the time registers at the next pps.
-     * \param time_spec the new time
-     */
-    virtual void set_time_next_pps(const ::osmosdr::time_spec_t &time_spec) = 0;
-
-    /*!
-     * Sync the time registers with an unknown pps edge.
-     * \param time_spec the new time
-     */
-    virtual void set_time_unknown_pps(const ::osmosdr::time_spec_t &time_spec) = 0;
+  static sptr make( const std::string & args = "" );
+
+  /*!
+   * Get the number of channels the underlying radio hardware offers.
+   * \return the number of available channels
+   */
+  virtual size_t get_num_channels( void ) = 0;
+
+  /*!
+   * \brief seek file to \p seek_point relative to \p whence
+   *
+   * \param seek_point	sample offset in file
+   * \param whence	one of SEEK_SET, SEEK_CUR, SEEK_END (man fseek)
+   * \return true on success
+   */
+  virtual bool seek( long seek_point, int whence, size_t chan = 0 ) = 0;
+
+  /*!
+   * Get the possible sample rates for the underlying radio hardware.
+   * \return a range of rates in Sps
+   */
+  virtual osmosdr::meta_range_t get_sample_rates( void ) = 0;
+
+  /*!
+   * Set the sample rate for the underlying radio hardware.
+   * This also will select the appropriate IF bandpass, if applicable.
+   * \param rate a new rate in Sps
+   */
+  virtual double set_sample_rate( double rate ) = 0;
+
+  /*!
+   * Get the sample rate for the underlying radio hardware.
+   * This is the actual sample rate and may differ from the rate set.
+   * \return the actual rate in Sps
+   */
+  virtual double get_sample_rate( void ) = 0;
+
+  /*!
+   * Get the tunable frequency range for the underlying radio hardware.
+   * \param chan the channel index 0 to N-1
+   * \return the frequency range in Hz
+   */
+  virtual osmosdr::freq_range_t get_freq_range( size_t chan = 0 ) = 0;
+
+  /*!
+   * Tune the underlying radio hardware to the desired center frequency.
+   * This also will select the appropriate RF bandpass.
+   * \param freq the desired frequency in Hz
+   * \param chan the channel index 0 to N-1
+   * \return the actual frequency in Hz
+   */
+  virtual double set_center_freq( double freq, size_t chan = 0 ) = 0;
+
+  /*!
+   * Get the center frequency the underlying radio hardware is tuned to.
+   * This is the actual frequency and may differ from the frequency set.
+   * \param chan the channel index 0 to N-1
+   * \return the frequency in Hz
+   */
+  virtual double get_center_freq( size_t chan = 0 ) = 0;
+
+  /*!
+   * Set the frequency correction value in parts per million.
+   * \param ppm the desired correction value in parts per million
+   * \param chan the channel index 0 to N-1
+   * \return correction value in parts per million
+   */
+  virtual double set_freq_corr( double ppm, size_t chan = 0 ) = 0;
+
+  /*!
+   * Get the frequency correction value.
+   * \param chan the channel index 0 to N-1
+   * \return correction value in parts per million
+   */
+  virtual double get_freq_corr( size_t chan = 0 ) = 0;
+
+  /*!
+   * Get the gain stage names of the underlying radio hardware.
+   * \param chan the channel index 0 to N-1
+   * \return a vector of strings containing the names of gain stages
+   */
+  virtual std::vector<std::string> get_gain_names( size_t chan = 0 ) = 0;
+
+  /*!
+   * Get the settable overall gain range for the underlying radio hardware.
+   * \param chan the channel index 0 to N-1
+   * \return the gain range in dB
+   */
+  virtual osmosdr::gain_range_t get_gain_range( size_t chan = 0 ) = 0;
+
+  /*!
+   * Get the settable gain range for a specific gain stage.
+   * \param name the name of the gain stage
+   * \param chan the channel index 0 to N-1
+   * \return the gain range in dB
+   */
+  virtual osmosdr::gain_range_t get_gain_range( const std::string & name,
+                                                size_t chan = 0 ) = 0;
+
+  /*!
+   * Set the gain mode for the underlying radio hardware.
+   * This might be supported only for certain hardware types.
+   * \param automatic the gain mode (true means automatic gain mode)
+   * \param chan the channel index 0 to N-1
+   * \return the actual gain mode
+   */
+  virtual bool set_gain_mode( bool automatic, size_t chan = 0 ) = 0;
+
+  /*!
+   * Get the gain mode selected for the underlying radio hardware.
+   * \param chan the channel index 0 to N-1
+   * \return the actual gain mode (true means automatic gain mode)
+   */
+  virtual bool get_gain_mode( size_t chan = 0 ) = 0;
+
+  /*!
+   * Set the gain for the underlying radio hardware.
+   * This function will automatically distribute the desired gain value over
+   * available gain stages in an appropriate way and return the actual value.
+   * \param gain the gain in dB
+   * \param chan the channel index 0 to N-1
+   * \return the actual gain in dB
+   */
+  virtual double set_gain( double gain, size_t chan = 0 ) = 0;
+
+  /*!
+   * Set the named gain on the underlying radio hardware.
+   * \param gain the gain in dB
+   * \param name the name of the gain stage
+   * \param chan the channel index 0 to N-1
+   * \return the actual gain in dB
+   */
+  virtual double set_gain( double gain,
+                           const std::string & name,
+                           size_t chan = 0 ) = 0;
+
+  /*!
+   * Get the actual gain setting of the underlying radio hardware.
+   * \param chan the channel index 0 to N-1
+   * \return the actual gain in dB
+   */
+  virtual double get_gain( size_t chan = 0 ) = 0;
+
+  /*!
+   * Get the actual gain setting of a named stage.
+   * \param name the name of the gain stage
+   * \param chan the channel index 0 to N-1
+   * \return the actual gain in dB
+   */
+  virtual double get_gain( const std::string & name, size_t chan = 0 ) = 0;
+
+  /*!
+   * Set the IF gain for the underlying radio hardware.
+   * This function will automatically distribute the desired gain value over
+   * available IF gain stages in an appropriate way and return the actual value.
+   * \param gain the gain in dB
+   * \param chan the channel index 0 to N-1
+   * \return the actual gain in dB
+   */
+  virtual double set_if_gain( double gain, size_t chan = 0 ) = 0;
+
+  /*!
+   * Set the BB gain for the underlying radio hardware.
+   * This function will automatically distribute the desired gain value over
+   * available BB gain stages in an appropriate way and return the actual value.
+   * \param gain the gain in dB
+   * \param chan the channel index 0 to N-1
+   * \return the actual gain in dB
+   */
+  virtual double set_bb_gain( double gain, size_t chan = 0 ) = 0;
+
+  /*!
+   * Get the available antennas of the underlying radio hardware.
+   * \param chan the channel index 0 to N-1
+   * \return a vector of strings containing the names of available antennas
+   */
+  virtual std::vector< std::string > get_antennas( size_t chan = 0 ) = 0;
+
+  /*!
+   * Select the active antenna of the underlying radio hardware.
+   * \param antenna name of the antenna to be selected
+   * \param chan the channel index 0 to N-1
+   * \return the actual antenna's name
+   */
+  virtual std::string set_antenna( const std::string & antenna,
+                                   size_t chan = 0 ) = 0;
+
+  /*!
+   * Get the actual underlying radio hardware antenna setting.
+   * \param chan the channel index 0 to N-1
+   * \return the actual antenna's name
+   */
+  virtual std::string get_antenna( size_t chan = 0 ) = 0;
+
+  enum DCOffsetMode {
+    DCOffsetOff = 0,
+    DCOffsetManual,
+    DCOffsetAutomatic
+  };
+
+  /*!
+   * Set the RX frontend DC correction mode.
+   * The automatic correction subtracts out the long-run average.
+   *
+   * When disabled, the averaging option operation is reset.
+   * Once in Manual mode, the average value will be held constant until
+   * the user re-enables the automatic correction or overrides the
+   * value by manually setting the offset.
+   *
+   * \param mode dc offset correction mode: 0 = Off, 1 = Manual, 2 = Automatic
+   * \param chan the channel index 0 to N-1
+   */
+  virtual void set_dc_offset_mode( int mode, size_t chan = 0) = 0;
+
+  /*!
+   * Set the RX frontend DC offset value.
+   * The value is complex to control both I and Q.
+   * Only set this when automatic correction is disabled.
+   *
+   * \param offset the dc offset (1.0 is full-scale)
+   * \param chan the channel index 0 to N-1
+   */
+  virtual void set_dc_offset( const std::complex<double> &offset, size_t chan = 0 ) = 0;
+
+  enum IQBalanceMode {
+    IQBalanceOff = 0,
+    IQBalanceManual,
+    IQBalanceAutomatic
+  };
+
+  /*!
+   * Set the RX frontend IQ balance mode.
+   *
+   * \param mode iq balance correction mode: 0 = Off, 1 = Manual, 2 = Automatic
+   * \param chan the channel index 0 to N-1
+   */
+  virtual void set_iq_balance_mode( int mode, size_t chan = 0 ) = 0;
+
+  /*!
+   * Set the RX frontend IQ balance correction.
+   * Use this to adjust the magnitude and phase of I and Q.
+   *
+   * \param balance the complex correction value
+   * \param chan the channel index 0 to N-1
+   */
+  virtual void set_iq_balance( const std::complex<double> &balance, size_t chan = 0 ) = 0;
+
+  /*!
+   * Set the bandpass filter on the radio frontend.
+   * \param bandwidth the filter bandwidth in Hz, set to 0 for automatic selection
+   * \param chan the channel index 0 to N-1
+   * \return the actual filter bandwidth in Hz
+   */
+  virtual double set_bandwidth( double bandwidth, size_t chan = 0 ) = 0;
+
+  /*!
+   * Get the actual bandpass filter setting on the radio frontend.
+   * \param chan the channel index 0 to N-1
+   * \return the actual filter bandwidth in Hz
+   */
+  virtual double get_bandwidth( size_t chan = 0 ) = 0;
+
+  /*!
+   * Get the possible bandpass filter settings on the radio frontend.
+   * \param chan the channel index 0 to N-1
+   * \return a range of bandwidths in Hz
+   */
+  virtual osmosdr::freq_range_t get_bandwidth_range( size_t chan = 0 ) = 0;
+
+  /*!
+   * Set the time source for the device.
+   * This sets the method of time synchronization,
+   * typically a pulse per second or an encoded time.
+   * Typical options for source: external, MIMO.
+   * \param source a string representing the time source
+   * \param mboard which motherboard to set the config
+   */
+  virtual void set_time_source(const std::string &source,
+                               const size_t mboard = 0) = 0;
+
+  /*!
+   * Get the currently set time source.
+   * \param mboard which motherboard to get the config
+   * \return the string representing the time source
+   */
+  virtual std::string get_time_source(const size_t mboard) = 0;
+
+  /*!
+   * Get a list of possible time sources.
+   * \param mboard which motherboard to get the list
+   * \return a vector of strings for possible settings
+   */
+  virtual std::vector<std::string> get_time_sources(const size_t mboard) = 0;
+
+  /*!
+   * Set the clock source for the device.
+   * This sets the source for a 10 Mhz reference clock.
+   * Typical options for source: internal, external, MIMO.
+   * \param source a string representing the clock source
+   * \param mboard which motherboard to set the config
+   */
+  virtual void set_clock_source(const std::string &source,
+                                const size_t mboard = 0) = 0;
+
+  /*!
+   * Get the currently set clock source.
+   * \param mboard which motherboard to get the config
+   * \return the string representing the clock source
+   */
+  virtual std::string get_clock_source(const size_t mboard) = 0;
+
+  /*!
+   * Get a list of possible clock sources.
+   * \param mboard which motherboard to get the list
+   * \return a vector of strings for possible settings
+   */
+  virtual std::vector<std::string> get_clock_sources(const size_t mboard) = 0;
+
+  /*!
+   * Get the master clock rate.
+   * \param mboard the motherboard index 0 to M-1
+   * \return the clock rate in Hz
+   */
+  virtual double get_clock_rate(size_t mboard = 0) = 0;
+
+  /*!
+   * Set the master clock rate.
+   * \param rate the new rate in Hz
+   * \param mboard the motherboard index 0 to M-1
+   */
+  virtual void set_clock_rate(double rate, size_t mboard = 0) = 0;
+
+  /*!
+   * Get the current time registers.
+   * \param mboard the motherboard index 0 to M-1
+   * \return the current device time
+   */
+  virtual ::osmosdr::time_spec_t get_time_now(size_t mboard = 0) = 0;
+
+  /*!
+   * Get the time when the last pps pulse occured.
+   * \param mboard the motherboard index 0 to M-1
+   * \return the current device time
+   */
+  virtual ::osmosdr::time_spec_t get_time_last_pps(size_t mboard = 0) = 0;
+
+  /*!
+   * Sets the time registers immediately.
+   * \param time_spec the new time
+   * \param mboard the motherboard index 0 to M-1
+   */
+  virtual void set_time_now(const ::osmosdr::time_spec_t &time_spec,
+                            size_t mboard = 0) = 0;
+
+  /*!
+   * Set the time registers at the next pps.
+   * \param time_spec the new time
+   */
+  virtual void set_time_next_pps(const ::osmosdr::time_spec_t &time_spec) = 0;
+
+  /*!
+   * Sync the time registers with an unknown pps edge.
+   * \param time_spec the new time
+   */
+  virtual void set_time_unknown_pps(const ::osmosdr::time_spec_t &time_spec) = 0;
 };
 
-} // namespace osmosdr
+} /* namespace osmosdr */
 
 #endif /* INCLUDED_OSMOSDR_SOURCE_H */
-
diff --git a/lib/CMakeLists.txt b/lib/CMakeLists.txt
index d05da32..29fd6d0 100644
--- a/lib/CMakeLists.txt
+++ b/lib/CMakeLists.txt
@@ -21,7 +21,6 @@
 # Setup library
 ########################################################################
 INCLUDE(GrPlatform) #define LIB_SUFFIX
-INCLUDE(OsmoSDRMiscUtils)
 INCLUDE(GrMiscUtils)
 INCLUDE(GrComponent)
 
@@ -119,11 +118,11 @@ SET_SOURCE_FILES_PROPERTIES(
 ########################################################################
 # Setup IQBalance component
 ########################################################################
-GR_REGISTER_COMPONENT("Osmocom IQ Imbalance Correction" ENABLE_IQBALANCE gnuradio-iqbalance_FOUND)
+GR_REGISTER_COMPONENT("Osmocom IQ Imbalance Correction" ENABLE_IQBALANCE GNURADIO_IQBALANCE_FOUND)
 if(ENABLE_IQBALANCE)
 add_definitions(-DHAVE_IQBALANCE=1)
-include_directories(${IQBALANCE_INCLUDE_DIRS})
-GR_OSMOSDR_APPEND_LIBS(${IQBALANCE_LIBRARIES})
+include_directories(${GNURADIO_IQBALANCE_INCLUDE_DIRS})
+GR_OSMOSDR_APPEND_LIBS(${GNURADIO_IQBALANCE_LIBRARIES})
 endif(ENABLE_IQBALANCE)
 
 ########################################################################
@@ -137,7 +136,7 @@ endif(ENABLE_OSMOSDR)
 ########################################################################
 # Setup File component
 ########################################################################
-GR_REGISTER_COMPONENT("IQ File Source & Sink" ENABLE_FILE gnuradio-blocks_FOUND)
+GR_REGISTER_COMPONENT("IQ File Source & Sink" ENABLE_FILE GNURADIO_BLOCKS_FOUND)
 if(ENABLE_FILE)
 GR_INCLUDE_SUBDIRECTORY(file)
 endif(ENABLE_FILE)
@@ -153,7 +152,7 @@ endif(ENABLE_RTL)
 ########################################################################
 # Setup RTL_TCP component
 ########################################################################
-GR_REGISTER_COMPONENT("RTLSDR TCP Client" ENABLE_RTL_TCP gnuradio-blocks_FOUND)
+GR_REGISTER_COMPONENT("RTLSDR TCP Client" ENABLE_RTL_TCP GNURADIO_BLOCKS_FOUND)
 if(ENABLE_RTL_TCP)
 GR_INCLUDE_SUBDIRECTORY(rtl_tcp)
 endif(ENABLE_RTL_TCP)
@@ -161,7 +160,7 @@ endif(ENABLE_RTL_TCP)
 ########################################################################
 # Setup UHD component
 ########################################################################
-GR_REGISTER_COMPONENT("Ettus USRP Devices" ENABLE_UHD UHD_FOUND gnuradio-uhd_FOUND)
+GR_REGISTER_COMPONENT("Ettus USRP Devices" ENABLE_UHD UHD_FOUND GNURADIO_UHD_FOUND)
 if(ENABLE_UHD)
 GR_INCLUDE_SUBDIRECTORY(uhd)
 endif(ENABLE_UHD)
@@ -270,4 +269,4 @@ ENDIF(MSVC)
 ADD_LIBRARY(gnuradio-osmosdr SHARED ${gr_osmosdr_srcs})
 TARGET_LINK_LIBRARIES(gnuradio-osmosdr ${gr_osmosdr_libs})
 SET_TARGET_PROPERTIES(gnuradio-osmosdr PROPERTIES DEFINE_SYMBOL "gnuradio_osmosdr_EXPORTS")
-GR_LIBRARY_FOO_V2(gnuradio-osmosdr)
+GR_LIBRARY_FOO(gnuradio-osmosdr)
diff --git a/python/CMakeLists.txt b/python/CMakeLists.txt
index 883f119..8841f36 100644
--- a/python/CMakeLists.txt
+++ b/python/CMakeLists.txt
@@ -1,7 +1,6 @@
 # Copyright 2011 Free Software Foundation, Inc.
 #
-# This file was generated by gr_modtool, a tool from the GNU Radio framework
-# This file is a part of gr-osmosdr
+# This file is part of GNU Radio
 #
 # GNU Radio is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
diff --git a/python/__init__.py b/python/__init__.py
index bc8240f..70c469d 100644
--- a/python/__init__.py
+++ b/python/__init__.py
@@ -19,16 +19,17 @@
 # The presence of this file turns this directory into a Python package
 
 '''
-This is the GNU Radio OSMOSDR module. Place your Python package
-description here (python/__init__.py).
+This is the GNU Radio OsmoSDR module.
 '''
+
 from __future__ import unicode_literals
 
 # import swig generated symbols into the osmosdr namespace
 try:
     # this might fail if the module is python-only
     from .osmosdr_swig import *
-except ImportError:
+except ImportError as ie:
+    print(ie)
     pass
 
 # import any pure python here
diff --git a/swig/CMakeLists.txt b/swig/CMakeLists.txt
index aabc555..d01d029 100644
--- a/swig/CMakeLists.txt
+++ b/swig/CMakeLists.txt
@@ -1,7 +1,6 @@
 # Copyright 2011 Free Software Foundation, Inc.
 #
-# This file was generated by gr_modtool, a tool from the GNU Radio framework
-# This file is a part of gr-osmosdr
+# This file is part of GNU Radio
 #
 # GNU Radio is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
@@ -21,10 +20,10 @@
 ########################################################################
 # Check if there is C++ code at all
 ########################################################################
-if(NOT osmosdr_sources)
-    MESSAGE(STATUS "No C++ sources... skipping swig/")
-    return()
-endif(NOT osmosdr_sources)
+#if(NOT osmosdr_sources)
+#    MESSAGE(STATUS "No C++ sources... skipping swig/")
+#    return()
+#endif(NOT osmosdr_sources)
 
 ########################################################################
 # Include swig generation macros
@@ -40,6 +39,9 @@ include(GrPython)
 ########################################################################
 # Setup swig generation
 ########################################################################
+foreach(incdir ${GNURADIO_ALL_INCLUDE_DIRS})
+    list(APPEND GR_SWIG_INCLUDE_DIRS ${incdir}/gnuradio/swig)
+endforeach(incdir)
 set(GR_SWIG_INCLUDE_DIRS $<TARGET_PROPERTY:gnuradio::runtime_swig,INTERFACE_INCLUDE_DIRECTORIES>)
 set(GR_SWIG_TARGET_DEPS gnuradio::runtime_swig)
 
diff --git a/swig/osmosdr_swig.i b/swig/osmosdr_swig.i
index 5e38c0a..550008b 100644
--- a/swig/osmosdr_swig.i
+++ b/swig/osmosdr_swig.i
@@ -2,17 +2,81 @@
 
 #define OSMOSDR_API
 
-%include "gnuradio.i"           // the common stuff
+// suppress Warning 319: No access specifier given for base class 'boost::noncopyable' (ignored).
+#pragma SWIG nowarn=319
+
+%include "gnuradio.i"			// the common stuff
 
 //load generated python docstrings
 %include "osmosdr_swig_doc.i"
 
 %{
+#include "osmosdr/device.h"
 #include "osmosdr/source.h"
 #include "osmosdr/sink.h"
 %}
 
+// Workaround for a SWIG 2.0.4 bug with templates. Probably needs to be looked in to.
+%{
+#if PY_VERSION_HEX >= 0x03020000
+# define SWIGPY_SLICE_ARG(obj) ((PyObject*) (obj))
+#else
+# define SWIGPY_SLICE_ARG(obj) ((PySliceObject*) (obj))
+#endif
+%}
+
+%template(string_vector_t) std::vector<std::string>;
+
+//%template(size_vector_t) std::vector<size_t>;
+
+%include <osmosdr/pimpl.h>
+
+%ignore osmosdr::device_t::operator[]; //ignore warnings about %extend
+
+%template(string_string_dict_t) std::map<std::string, std::string>; //define before device
+%template(devices_t) std::vector<osmosdr::device_t>;
+%include <osmosdr/device.h>
+
+//%extend std::map<std::string, std::string>{
+//    std::string __getitem__(std::string key) {return (*self)[key];}
+//    void __setitem__(std::string key, std::string val) {(*self)[key] = val;}
+//};
+
+%template(range_vector_t) std::vector<osmosdr::range_t>; //define before range
+%include <osmosdr/ranges.h>
+
+%include <osmosdr/time_spec.h>
+
+%extend osmosdr::time_spec_t{
+    osmosdr::time_spec_t __add__(const osmosdr::time_spec_t &what)
+    {
+        osmosdr::time_spec_t temp = *self;
+        temp += what;
+        return temp;
+    }
+    osmosdr::time_spec_t __sub__(const osmosdr::time_spec_t &what)
+    {
+        osmosdr::time_spec_t temp = *self;
+        temp -= what;
+        return temp;
+    }
+};
+
+%define OSMOSDR_SWIG_BLOCK_MAGIC2(PKG, BASE_NAME)
+%template(BASE_NAME ## _sptr) boost::shared_ptr<PKG ## :: ## BASE_NAME>;
+%pythoncode %{
+BASE_NAME ## _sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
+BASE_NAME = BASE_NAME.make;
+%}
+%enddef
+
 %include "osmosdr/source.h"
-GR_SWIG_BLOCK_MAGIC2(osmosdr, source);
 %include "osmosdr/sink.h"
-GR_SWIG_BLOCK_MAGIC2(osmosdr, sink);
+
+OSMOSDR_SWIG_BLOCK_MAGIC2(osmosdr,source);
+OSMOSDR_SWIG_BLOCK_MAGIC2(osmosdr,sink);
+
+%{
+static const size_t ALL_MBOARDS = osmosdr::ALL_MBOARDS;
+%}
+//static const size_t ALL_MBOARDS;
-- 
2.20.1

