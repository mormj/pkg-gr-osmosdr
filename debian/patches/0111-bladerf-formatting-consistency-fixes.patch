From 399db9138535056eb7b15a864fe2abb12bae7674 Mon Sep 17 00:00:00 2001
From: Ryan Tucker <ryan.tucker@nuand.com>
Date: Wed, 28 Jun 2017 14:03:29 -0400
Subject: [PATCH 111/131] bladerf: formatting/consistency fixes

---
 lib/bladerf/bladerf_common.cc   | 769 ++++++++++++++++----------------
 lib/bladerf/bladerf_sink_c.cc   | 215 ++++-----
 lib/bladerf/bladerf_source_c.cc | 263 ++++++-----
 3 files changed, 645 insertions(+), 602 deletions(-)

diff --git a/lib/bladerf/bladerf_common.cc b/lib/bladerf/bladerf_common.cc
index ff7f338..f6938ac 100644
--- a/lib/bladerf/bladerf_common.cc
+++ b/lib/bladerf/bladerf_common.cc
@@ -46,14 +46,14 @@
 using namespace boost::assign;
 
 boost::mutex bladerf_common::_devs_mutex;
-std::list<boost::weak_ptr<struct bladerf> > bladerf_common::_devs;
+std::list < boost::weak_ptr < struct bladerf >> bladerf_common::_devs;
 
 /* name of system-wide gain
  * (internal only, doesn't match any libbladeRF gain stage)
  */
-static const char* SYSTEM_GAIN_NAME = "system";
+static const char *SYSTEM_GAIN_NAME = "system";
 
-bladerf_common::bladerf_common() :
+bladerf_common::bladerf_common():
   _conv_buf(NULL),
   _conv_buf_size(4096),
   _xb_200_attached(false),
@@ -66,17 +66,18 @@ bladerf_common::~bladerf_common()
   free(_conv_buf);
 }
 
-bladerf_board_type bladerf_common::get_board_type( struct bladerf *dev )
+bladerf_board_type bladerf_common::get_board_type(struct bladerf *dev)
 {
-  std::string boardname = std::string( bladerf_get_board_name(dev) );
+  std::string boardname = std::string(bladerf_get_board_name(dev));
 
-  if ( boardname == "bladerf1" ) {
+  if (boardname == "bladerf1") {
     return BLADERF_REV_1;
-  } else if ( boardname == "bladerf2" ) {
+  } else if (boardname == "bladerf2") {
     return BLADERF_REV_2;
   }
 
-  std::cerr << _pfx << "board name \"" << boardname << "\" unknown"
+  std::cerr << _pfx
+            << "board name \"" << boardname << "\" unknown"
             << std::endl;
   return BLADERF_REV_INVALID;
 }
@@ -84,19 +85,18 @@ bladerf_board_type bladerf_common::get_board_type( struct bladerf *dev )
 bladerf_sptr bladerf_common::get_cached_device( struct bladerf_devinfo devinfo )
 {
   /* Lock to _devs must be aquired by caller */
-  BOOST_FOREACH( boost::weak_ptr<struct bladerf> dev, _devs )
-  {
+  BOOST_FOREACH(boost::weak_ptr < struct bladerf >dev, _devs) {
     int status;
     struct bladerf_devinfo other_devinfo;
 
-    status = bladerf_get_devinfo( bladerf_sptr(dev).get(), &other_devinfo );
-    if ( status < 0 ) {
-      throw std::runtime_error( std::string(__FUNCTION__) +
-                                "Failed to get devinfo for cached device: " +
-                                bladerf_strerror(status) );
+    status = bladerf_get_devinfo(bladerf_sptr(dev).get(), &other_devinfo);
+    if (status < 0) {
+      throw std::runtime_error(std::string(__FUNCTION__) +
+                               "Failed to get devinfo for cached device: " +
+                               bladerf_strerror(status));
     }
 
-    if ( bladerf_devinfo_matches(&devinfo, &other_devinfo) ) {
+    if (bladerf_devinfo_matches(&devinfo, &other_devinfo)) {
       return bladerf_sptr(dev);
     }
   }
@@ -105,40 +105,40 @@ bladerf_sptr bladerf_common::get_cached_device( struct bladerf_devinfo devinfo )
 }
 
 /* This is called when a bladerf_sptr hits a refcount of 0 */
-void bladerf_common::close( void* dev )
+void bladerf_common::close(void *dev)
 {
-  boost::unique_lock<boost::mutex> lock(_devs_mutex);
-  std::list<boost::weak_ptr<struct bladerf> >::iterator it(_devs.begin());
+  boost::unique_lock < boost::mutex > lock(_devs_mutex);
+  std::list < boost::weak_ptr < struct bladerf >>::iterator it(_devs.begin());
 
   /* Prune expired entries from device cache */
-  while ( it != _devs.end() ) {
-    if ( (*it).expired() ) {
+  while (it != _devs.end()) {
+    if ((*it).expired()) {
       it = _devs.erase(it);
     } else {
       ++it;
     }
   }
 
-  bladerf_close( static_cast<struct bladerf *>(dev) );
+  bladerf_close(static_cast<struct bladerf *>(dev));
 }
 
-bladerf_sptr bladerf_common::open( const std::string &device_name )
+bladerf_sptr bladerf_common::open(const std::string &device_name)
 {
   int status;
   struct bladerf *raw_dev = NULL;
   struct bladerf_devinfo devinfo;
 
-  boost::unique_lock<boost::mutex> lock(_devs_mutex);
+  boost::unique_lock < boost::mutex > lock(_devs_mutex);
 
   /* Initialize the information used to identify the desired device
    * to all wildcard (i.e., "any device") values */
-  bladerf_init_devinfo( &devinfo );
+  bladerf_init_devinfo(&devinfo);
 
   /* Populate the devinfo structure from device_name */
-  status = bladerf_get_devinfo_from_str( device_name.c_str(), &devinfo );
-  if ( status < 0 ) {
-    throw std::runtime_error( _pfx + "Failed to get devinfo for '" +
-                              device_name + "': " + bladerf_strerror(status) );
+  status = bladerf_get_devinfo_from_str(device_name.c_str(), &devinfo);
+  if (status < 0) {
+    throw std::runtime_error(_pfx + "Failed to get devinfo for '" +
+                             device_name + "': " + bladerf_strerror(status));
   }
 
   /* Do we already have this device open? */
@@ -149,87 +149,91 @@ bladerf_sptr bladerf_common::open( const std::string &device_name )
   }
 
   /* Open the device. */
-  status = bladerf_open_with_devinfo( &raw_dev, &devinfo );
-  if ( status < 0 ) {
-    throw std::runtime_error( _pfx + "Failed to open device for '" +
-                              device_name + "': " + bladerf_strerror(status) );
+  status = bladerf_open_with_devinfo(&raw_dev, &devinfo);
+  if (status < 0) {
+    throw std::runtime_error(_pfx + "Failed to open device for '" +
+                             device_name + "': " + bladerf_strerror(status));
   }
 
   /* Add the device handle to our cache */
-  bladerf_sptr dev = bladerf_sptr( raw_dev, bladerf_common::close );
+  bladerf_sptr dev = bladerf_sptr(raw_dev, bladerf_common::close);
 
-  _devs.push_back( boost::weak_ptr<struct bladerf>(dev) );
+  _devs.push_back(boost::weak_ptr < struct bladerf >(dev));
 
   return dev;
 }
 
-void bladerf_common::set_loopback_mode( const std::string &loopback )
+void bladerf_common::set_loopback_mode(const std::string &loopback)
 {
   int status;
   bladerf_loopback mode;
 
-  if ( loopback == "bb_txlpf_rxvga2" ) {
+  if (loopback == "bb_txlpf_rxvga2") {
     mode = BLADERF_LB_BB_TXLPF_RXVGA2;
-  } else if ( loopback == "bb_txlpf_rxlpf" ) {
+  } else if (loopback == "bb_txlpf_rxlpf") {
     mode = BLADERF_LB_BB_TXLPF_RXLPF;
-  } else if ( loopback == "bb_txvga1_rxvga2" ) {
+  } else if (loopback == "bb_txvga1_rxvga2") {
     mode = BLADERF_LB_BB_TXVGA1_RXVGA2;
-  } else if ( loopback == "bb_txvga1_rxlpf" ) {
+  } else if (loopback == "bb_txvga1_rxlpf") {
     mode = BLADERF_LB_BB_TXVGA1_RXLPF;
-  } else if ( loopback == "rf_lna1" ) {
+  } else if (loopback == "rf_lna1") {
     mode = BLADERF_LB_RF_LNA1;
-  } else if ( loopback == "rf_lna2" ) {
+  } else if (loopback == "rf_lna2") {
     mode = BLADERF_LB_RF_LNA2;
-  } else if ( loopback == "rf_lna3" ) {
+  } else if (loopback == "rf_lna3") {
     mode = BLADERF_LB_RF_LNA3;
-  } else if ( loopback == "ad9361_bist" ) {
+  } else if (loopback == "ad9361_bist") {
     mode = BLADERF_LB_AD9361_BIST;
-  } else if ( loopback == "none" ) {
+  } else if (loopback == "none") {
     mode = BLADERF_LB_NONE;
   } else {
-    throw std::runtime_error( _pfx + "Unknown loopback mode: " + loopback );
+    throw std::runtime_error(_pfx + "Unknown loopback mode: " + loopback);
   }
 
-  status = bladerf_set_loopback( _dev.get(), mode);
-  if ( status != 0 ) {
+  status = bladerf_set_loopback(_dev.get(), mode);
+  if (status != 0) {
     // TODO: handle BLADERF_ERR_UNSUPPORTED more gingerly
-    throw std::runtime_error( _pfx + "Failed to set loopback mode: " +
-                              bladerf_strerror(status) );
+    throw std::runtime_error(_pfx + "Failed to set loopback mode: " +
+                             bladerf_strerror(status));
   }
 }
 
-void bladerf_common::set_verbosity( const std::string &verbosity )
+void bladerf_common::set_verbosity(const std::string &verbosity)
 {
   bladerf_log_level l;
 
-  if ( verbosity == "verbose" ) {
+  if (verbosity == "verbose") {
     l = BLADERF_LOG_LEVEL_VERBOSE;
-  } else if ( verbosity == "debug" ) {
+  } else if (verbosity == "debug") {
     l = BLADERF_LOG_LEVEL_DEBUG;
-  } else if ( verbosity == "info" ) {
+  } else if (verbosity == "info") {
     l = BLADERF_LOG_LEVEL_INFO;
-  } else if ( verbosity == "warning" ) {
+  } else if (verbosity == "warning") {
     l = BLADERF_LOG_LEVEL_WARNING;
-  } else if ( verbosity == "error" ) {
+  } else if (verbosity == "error") {
     l = BLADERF_LOG_LEVEL_ERROR;
-  } else if ( verbosity == "critical" ) {
+  } else if (verbosity == "critical") {
     l = BLADERF_LOG_LEVEL_CRITICAL;
-  } else if ( verbosity == "silent" ) {
+  } else if (verbosity == "silent") {
     l = BLADERF_LOG_LEVEL_SILENT;
   } else {
-    throw std::runtime_error( _pfx + "Invalid log level: " + verbosity );
+    throw std::runtime_error(_pfx + "Invalid log level: " + verbosity);
   }
 
   bladerf_log_set_verbosity(l);
 }
 
-bool bladerf_common::start( bladerf_direction direction )
+bool bladerf_common::start(bladerf_direction direction)
 {
   int status;
   bladerf_format format;
   bladerf_channel_layout layout;
 
-  format = _use_metadata ? BLADERF_FORMAT_SC16_Q11_META : BLADERF_FORMAT_SC16_Q11;
+  if (_use_metadata) {
+    format = BLADERF_FORMAT_SC16_Q11_META;
+  } else {
+    format = BLADERF_FORMAT_SC16_Q11;
+  }
 
   switch (direction) {
     case BLADERF_RX:
@@ -239,58 +243,58 @@ bool bladerf_common::start( bladerf_direction direction )
       layout = _use_mimo ? BLADERF_TX_X2 : BLADERF_TX_X1;
       break;
     default:
-      throw std::runtime_error( _pfx + "Invalid direction: " +
-                                boost::lexical_cast<std::string>(direction) );
+      throw std::runtime_error(_pfx + "Invalid direction: " +
+                               boost::lexical_cast<std::string>(direction));
   }
 
-  status = bladerf_sync_config( _dev.get(), layout, format,
-                                _num_buffers, _samples_per_buffer,
-                                _num_transfers, _stream_timeout_ms );
-  if ( status != 0 ) {
-    throw std::runtime_error( _pfx + "bladerf_sync_config failed: " +
-                              bladerf_strerror(status) );
+  status = bladerf_sync_config(_dev.get(), layout, format,
+                               _num_buffers, _samples_per_buffer,
+                               _num_transfers, _stream_timeout_ms);
+  if (status != 0) {
+    throw std::runtime_error(_pfx + "bladerf_sync_config failed: " +
+                             bladerf_strerror(status));
   }
 
-  status = bladerf_enable_module( _dev.get(), direction, true );
-  if ( status != 0 ) {
-    throw std::runtime_error( _pfx + "bladerf_enable_module failed: " +
-                              bladerf_strerror(status) );
+  status = bladerf_enable_module(_dev.get(), direction, true);
+  if (status != 0) {
+    throw std::runtime_error(_pfx + "bladerf_enable_module failed: " +
+                             bladerf_strerror(status));
   }
 
   return true;
 }
 
-bool bladerf_common::stop( bladerf_direction direction )
+bool bladerf_common::stop(bladerf_direction direction)
 {
   int status;
 
-  status = bladerf_enable_module( _dev.get(), direction, false );
-  if ( status != 0 ) {
-    throw std::runtime_error( _pfx + "bladerf_enable_module failed: " +
-                              bladerf_strerror(status) );
+  status = bladerf_enable_module(_dev.get(), direction, false);
+  if (status != 0) {
+    throw std::runtime_error(_pfx + "bladerf_enable_module failed: " +
+                             bladerf_strerror(status));
   }
 
   return true;
 }
 
-static bool version_greater_or_equal( const struct bladerf_version *version,
-                                      unsigned int major, unsigned int minor,
-                                      unsigned int patch )
+static bool version_greater_or_equal(const struct bladerf_version *version,
+                                     unsigned int major,
+                                     unsigned int minor, unsigned int patch)
 {
-  if ( version->major > major ) {
+  if (version->major > major) {
     return true;
-  } else if ( (version->major == major) && (version->minor > minor) ) {
+  } else if ((version->major == major) && (version->minor > minor)) {
     return true;
-  } else if ( (version->major == major) &&
-              (version->minor == minor) &&
-              (version->patch >= patch) ) {
+  } else if ((version->major == major) &&
+             (version->minor == minor) &&
+             (version->patch >= patch)) {
     return true;
   } else {
     return false;
   }
 }
 
-void bladerf_common::init( dict_t &dict, bladerf_direction direction )
+void bladerf_common::init(dict_t &dict, bladerf_direction direction)
 {
   int status;
   std::string device_name("");
@@ -300,23 +304,23 @@ void bladerf_common::init( dict_t &dict, bladerf_direction direction )
 
   _pfx = std::string("[bladeRF ") + std::string(type) + std::string("] ");
 
-  if ( dict.count("verbosity") ) {
-      set_verbosity( dict["verbosity"] );
+  if (dict.count("verbosity")) {
+    set_verbosity(dict["verbosity"]);
   }
 
   if (dict.count("bladerf")) {
     const std::string value = dict["bladerf"];
-    if ( value.length() > 0 ) {
-      if ( value.length() <= 2 ) {
+    if (value.length() > 0) {
+      if (value.length() <= 2) {
         /* If the value is two digits or less, we'll assume the user is
          * providing an instance number */
         unsigned int device_number = 0;
 
         try {
-          device_number = boost::lexical_cast< unsigned int >( value );
-          device_name = boost::str(boost::format( "*:instance=%d" ) % device_number);
-        } catch ( std::exception &ex ) {
-          throw std::runtime_error( _pfx + "Failed to use '" + value +
+          device_number = boost::lexical_cast<unsigned int>(value);
+          device_name = boost::str(boost::format("*:instance=%d") % device_number);
+        } catch (std::exception &ex) {
+          throw std::runtime_error(_pfx + "Failed to use '" + value +
                                    "' as device number: " + ex.what());
         }
 
@@ -329,16 +333,16 @@ void bladerf_common::init( dict_t &dict, bladerf_direction direction )
          * may just pass whatever the user has provided.
          */
         bladerf_version(&ver);
-        if ( version_greater_or_equal(&ver, 1, 4, 1) ||
-             value.length() == (BLADERF_SERIAL_LENGTH - 1) ) {
+        if (version_greater_or_equal(&ver, 1, 4, 1) ||
+            value.length() == (BLADERF_SERIAL_LENGTH - 1)) {
           device_name = std::string("*:serial=") + value;
         } else {
-          throw std::runtime_error( _pfx +
-                                    "A full serial number must be supplied "
-                                    "with libbladeRF " +
-                                    std::string(ver.describe) +
-                                    ". libbladeRF >= v1.4.1 supports opening "
-                                    "a device via a subset of its serial #." );
+          throw std::runtime_error(_pfx +
+                                   "A full serial number must be supplied "
+                                   "with libbladeRF " +
+                                   std::string(ver.describe) +
+                                   ". libbladeRF >= v1.4.1 supports opening "
+                                   "a device via a subset of its serial #.");
         }
       }
     }
@@ -347,63 +351,67 @@ void bladerf_common::init( dict_t &dict, bladerf_direction direction )
   try {
     std::cerr << _pfx
               << "Opening nuand bladeRF with device identifier string: \""
-              << device_name << "\"" << std::endl;
+              << device_name << "\""
+              << std::endl;
 
     _dev = open(device_name);
-  } catch(...) {
-    throw std::runtime_error( _pfx + "Failed to open bladeRF device " +
-                              device_name );
+  } catch (...) {
+    throw std::runtime_error(_pfx + "Failed to open bladeRF device " +
+                             device_name);
   }
 
   /* Load an FPGA */
-  if ( dict.count("fpga") ) {
-    if ( dict.count("fpga-reload") == 0 &&
-         bladerf_is_fpga_configured( _dev.get() ) == 1 ) {
+  if (dict.count("fpga")) {
+    if (dict.count("fpga-reload") == 0 &&
+        bladerf_is_fpga_configured(_dev.get()) == 1) {
 
       std::cerr << _pfx
                 << "FPGA is already loaded. Set fpga-reload=1 to force a "
-                   "reload." << std::endl;
-
+                << "reload."
+                << std::endl;
     } else {
-
       std::string fpga = dict["fpga"];
 
-      std::cerr << _pfx << "Loading FPGA bitstream " << fpga << "..."
+      std::cerr << _pfx
+                << "Loading FPGA bitstream " << fpga << "..."
                 << std::endl;
 
-      status = bladerf_load_fpga( _dev.get(), fpga.c_str() );
-      if ( status != 0 ) {
-        std::cerr << _pfx << "bladerf_load_fpga has failed with "
-                  << bladerf_strerror(status) << std::endl;
+      status = bladerf_load_fpga(_dev.get(), fpga.c_str());
+      if (status != 0) {
+        std::cerr << _pfx
+                  << "bladerf_load_fpga has failed with "
+                  << bladerf_strerror(status)
+                  << std::endl;
       } else {
-        std::cerr << _pfx << "The FPGA bitstream was successfully loaded."
+        std::cerr << _pfx
+                  << "The FPGA bitstream was successfully loaded."
                   << std::endl;
       }
     }
   }
 
-  if ( bladerf_is_fpga_configured( _dev.get() ) != 1 ) {
-    throw std::runtime_error( _pfx + 
-                              "The FPGA is not configured! Provide device "
-                              "argument fpga=/path/to/the/bitstream.rbf to "
-                              "load it." );
+  if (bladerf_is_fpga_configured(_dev.get()) != 1) {
+    throw std::runtime_error(_pfx +
+                             "The FPGA is not configured! Provide device "
+                             "argument fpga=/path/to/the/bitstream.rbf to "
+                             "load it.");
   }
 
-  if ( direction == BLADERF_RX ) {
-    if ( dict.count("loopback") ) {
-      set_loopback_mode( dict["loopback"] );
+  if (direction == BLADERF_RX) {
+    if (dict.count("loopback")) {
+      set_loopback_mode(dict["loopback"]);
     } else {
-      set_loopback_mode( "none" );
+      set_loopback_mode("none");
     }
-  } else if ( direction == BLADERF_TX && dict.count("loopback") ) {
-      std::cerr << _pfx
-                << "Warning: 'loopback' has been specified on a bladeRF "
-                   "sink,  and will have no effect. This parameter should "
-                   "be specified on the associated bladeRF source."
-                << std::endl;
+  } else if (direction == BLADERF_TX && dict.count("loopback")) {
+    std::cerr << _pfx
+              << "Warning: 'loopback' has been specified on a bladeRF "
+              << "sink,  and will have no effect. This parameter should "
+              << "be specified on the associated bladeRF source."
+              << std::endl;
   }
 
-  if ( dict.count("xb200") ) {
+  if (dict.count("xb200")) {
     if (bladerf_expansion_attach(_dev.get(), BLADERF_XB_200)) {
       std::cerr << _pfx << "Could not attach XB-200" << std::endl;
     } else {
@@ -411,105 +419,112 @@ void bladerf_common::init( dict_t &dict, bladerf_direction direction )
 
       bladerf_xb200_filter filter = BLADERF_XB200_AUTO_1DB;
 
-      if ( dict["xb200"] == "custom" ) {
+      if (dict["xb200"] == "custom") {
         filter = BLADERF_XB200_CUSTOM;
-      } else if ( dict["xb200"] == "50M" ) {
+      } else if (dict["xb200"] == "50M") {
         filter = BLADERF_XB200_50M;
-      } else if ( dict["xb200"] == "144M" ) {
+      } else if (dict["xb200"] == "144M") {
         filter = BLADERF_XB200_144M;
-      } else if ( dict["xb200"] == "222M" ) {
+      } else if (dict["xb200"] == "222M") {
         filter = BLADERF_XB200_222M;
-      } else if ( dict["xb200"] == "auto3db" ) {
+      } else if (dict["xb200"] == "auto3db") {
         filter = BLADERF_XB200_AUTO_3DB;
-      } else if ( dict["xb200"] == "auto" ) {
+      } else if (dict["xb200"] == "auto") {
         filter = BLADERF_XB200_AUTO_1DB;
       } else {
         filter = BLADERF_XB200_AUTO_1DB;
       }
 
       status = bladerf_xb200_set_filterbank(_dev.get(), direction, filter);
-      if ( status != 0 ) {
-          std::cerr << _pfx << "Could not set XB-200 filter: " 
-                    << bladerf_strerror(status) << std::endl;
+      if (status != 0) {
+        std::cerr << _pfx
+                  << "Could not set XB-200 filter: "
+                  << bladerf_strerror(status)
+                  << std::endl;
       }
     }
   }
 
   /* Show some info about the device we've opened */
-
   std::cerr << _pfx;
 
-  if ( bladerf_get_serial( _dev.get(), serial ) == 0 ) {
+  if (bladerf_get_serial(_dev.get(), serial) == 0) {
     std::string strser(serial);
 
-    if ( strser.length() == 32 ) {
-      strser.replace( 4, 24, "..." );
+    if (strser.length() == 32) {
+      strser.replace(4, 24, "...");
     }
 
     std::cerr << " Serial # " << strser;
   }
 
-  if ( bladerf_fw_version( _dev.get(), &ver ) == 0 ) {
+  if (bladerf_fw_version(_dev.get(), &ver) == 0) {
     std::cerr << " FW v" << ver.major << "." << ver.minor << "." << ver.patch;
   }
 
-  if ( bladerf_fpga_version( _dev.get(), &ver ) == 0 ) {
+  if (bladerf_fpga_version(_dev.get(), &ver) == 0) {
     std::cerr << " FPGA v" << ver.major << "." << ver.minor << "." << ver.patch;
   }
 
   std::cerr << std::endl;
 
-  if ( dict.count("tamer") ) {
-    set_clock_source( dict["tamer"] );
-    std::cerr << _pfx << "Tamer mode set to '" << get_clock_source() << "'";
+  if (dict.count("tamer")) {
+    set_clock_source(dict["tamer"]);
+    std::cerr << _pfx
+              << "Tamer mode set to '" << get_clock_source() << "'"
+              << std::endl;
   }
 
-  if ( dict.count("smb") ) {
-    set_smb_frequency( boost::lexical_cast< double >( dict["smb"] ) );
-    std::cerr << _pfx << "SMB frequency set to " << get_smb_frequency() << " Hz";
+  if (dict.count("smb")) {
+    set_smb_frequency(boost::lexical_cast<double>(dict["smb"]));
+    std::cerr << _pfx
+              << "SMB frequency set to " << get_smb_frequency() << " Hz"
+              << std::endl;
   }
 
   /* Initialize buffer and sample configuration */
   _num_buffers = 0;
-  if ( dict.count("buffers") ) {
-    _num_buffers = boost::lexical_cast< size_t >( dict["buffers"] );
+  if (dict.count("buffers")) {
+    _num_buffers = boost::lexical_cast<size_t>(dict["buffers"]);
   }
 
   _samples_per_buffer = 0;
-  if ( dict.count("buflen") ) {
-    _samples_per_buffer = boost::lexical_cast< size_t >( dict["buflen"] );
+  if (dict.count("buflen")) {
+    _samples_per_buffer = boost::lexical_cast<size_t>(dict["buflen"]);
   }
 
   _num_transfers = 0;
-  if ( dict.count("transfers") ) {
-    _num_transfers = boost::lexical_cast< size_t >( dict["transfers"] );
+  if (dict.count("transfers")) {
+    _num_transfers = boost::lexical_cast<size_t>(dict["transfers"]);
   }
 
   _stream_timeout_ms = 3000;
-  if ( dict.count("stream_timeout_ms") ) {
-    _stream_timeout_ms = boost::lexical_cast< unsigned int >( dict["stream_timeout_ms"] );
+  if (dict.count("stream_timeout_ms")) {
+    _stream_timeout_ms = boost::lexical_cast<unsigned int>(dict["stream_timeout_ms"]);
   }
 
   _use_metadata = dict.count("enable_metadata") != 0;
 
-  _use_mimo = ( dict.count("enable_mimo") != 0 ) && ( get_num_channels(direction) >= 2 );
+  _use_mimo = (dict.count("enable_mimo") != 0) &&
+              (get_num_channels(direction) >= 2);
 
   /* Require value to be >= 2 so we can ensure we have twice as many
    * buffers as transfers */
-  if ( _num_buffers <= 1 ) {
+  if (_num_buffers <= 1) {
     _num_buffers = NUM_BUFFERS;
   }
 
-  if ( 0 == _samples_per_buffer ) {
+  if (0 == _samples_per_buffer) {
     _samples_per_buffer = NUM_SAMPLES_PER_BUFFER;
   } else {
-    if ( (_samples_per_buffer < 1024) || ((_samples_per_buffer % 1024) != 0) ) {
+    if ((_samples_per_buffer < 1024) ||
+        (_samples_per_buffer % 1024 != 0)) {
       /* 0 likely implies the user did not specify this, so don't warn */
-      if (_samples_per_buffer != 0 ) {
+      if (_samples_per_buffer != 0) {
         std::cerr << _pfx
                   << "Invalid \"buflen\" value. A multiple of 1024 is "
-                     "required. Defaulting to "
-                  << NUM_SAMPLES_PER_BUFFER << std::endl;
+                  << "required. Defaulting to " << NUM_SAMPLES_PER_BUFFER
+                  << std::endl;
       }
 
       _samples_per_buffer = NUM_SAMPLES_PER_BUFFER;
@@ -518,43 +533,42 @@ void bladerf_common::init( dict_t &dict, bladerf_direction direction )
 
   /* If the user hasn't specified the desired number of transfers, set it to
    * min(32, num_buffers / 2) */
-  if ( _num_transfers == 0 ) {
-      _num_transfers = _num_buffers / 2;
-
-      if (_num_transfers > 32) {
-          _num_transfers = 32;
-      }
+  if (_num_transfers == 0) {
+    _num_transfers = _num_buffers / 2;
 
-  } else if ( _num_transfers >= _num_buffers ) {
-      _num_transfers = _num_buffers - 1;
-      std::cerr << _pfx
-                << "Clamping num_tranfers to " << _num_transfers << ". "
-                   "Try using a smaller num_transfers value if timeouts occur."
-                << std::endl;
+    if (_num_transfers > 32) {
+      _num_transfers = 32;
+    }
+  } else if (_num_transfers >= _num_buffers) {
+    _num_transfers = _num_buffers - 1;
+    std::cerr << _pfx
+              << "Clamping num_tranfers to " << _num_transfers << ". "
+              << "Try using a smaller num_transfers value if timeouts occur."
+              << std::endl;
   }
 
-  _conv_buf = static_cast<int16_t*>(malloc(_conv_buf_size * 2 * sizeof(int16_t)));
+  _conv_buf = static_cast<int16_t *>(malloc(_conv_buf_size * 2 * sizeof(int16_t)));
 
-  if ( NULL == _conv_buf ) {
-    throw std::runtime_error( _pfx + "Failed to allocate _conv_buf" );
+  if (NULL == _conv_buf) {
+    throw std::runtime_error(_pfx + "Failed to allocate _conv_buf");
   }
 }
 
-osmosdr::freq_range_t bladerf_common::freq_range( bladerf_channel chan )
+osmosdr::freq_range_t bladerf_common::freq_range(bladerf_channel chan)
 {
   int status;
   struct bladerf_range range;
 
-  status = bladerf_get_frequency_range( _dev.get(), chan, &range );
+  status = bladerf_get_frequency_range(_dev.get(), chan, &range);
 
-  if( status ) {
-    throw std::runtime_error( _pfx +
-                              "bladerf_get_frequency_range failed: " +
-                              bladerf_strerror(status) );
+  if (status != 0) {
+    throw std::runtime_error(_pfx +
+                             "bladerf_get_frequency_range failed: " +
+                             bladerf_strerror(status));
   } else {
-    return osmosdr::freq_range_t( static_cast<double>(range.min),
-                                  static_cast<double>(range.max),
-                                  static_cast<double>(range.step) );
+    return osmosdr::freq_range_t(static_cast<double>(range.min),
+                                 static_cast<double>(range.max),
+                                 static_cast<double>(range.step));
   };
 }
 
@@ -565,23 +579,23 @@ osmosdr::meta_range_t bladerf_common::sample_rates()
   bladerf_range brf_sample_rates;
 
   /* assuming the same for RX & TX */
-  status = bladerf_get_sample_rate_range( _dev.get(), BLADERF_CHANNEL_RX(0),
-                                          &brf_sample_rates );
-  if( status ) {
-    throw std::runtime_error( _pfx +
-                              "bladerf_get_sample_rate_range failed: " +
-                              bladerf_strerror(status) );
-  }
-
-  sample_rates += osmosdr::range_t( brf_sample_rates.min,
-                                    brf_sample_rates.max/4.0,
-                                    brf_sample_rates.max/16.0 );
-  sample_rates += osmosdr::range_t( brf_sample_rates.max/4.0,
-                                    brf_sample_rates.max/2.0,
-                                    brf_sample_rates.max/8.0 );
-  sample_rates += osmosdr::range_t( brf_sample_rates.max/2.0,
-                                    brf_sample_rates.max,
-                                    brf_sample_rates.max/4.0 );
+  status = bladerf_get_sample_rate_range(_dev.get(), BLADERF_CHANNEL_RX(0),
+                                         &brf_sample_rates);
+  if (status != 0) {
+    throw std::runtime_error(_pfx +
+                             "bladerf_get_sample_rate_range failed: " +
+                             bladerf_strerror(status));
+  }
+
+  sample_rates += osmosdr::range_t(brf_sample_rates.min,
+                                   brf_sample_rates.max / 4.0,
+                                   brf_sample_rates.max / 16.0);
+  sample_rates += osmosdr::range_t(brf_sample_rates.max / 4.0,
+                                   brf_sample_rates.max / 2.0,
+                                   brf_sample_rates.max / 8.0);
+  sample_rates += osmosdr::range_t(brf_sample_rates.max / 2.0,
+                                   brf_sample_rates.max,
+                                   brf_sample_rates.max / 4.0);
 
   return sample_rates;
 }
@@ -593,12 +607,12 @@ osmosdr::freq_range_t bladerf_common::filter_bandwidths()
   osmosdr::freq_range_t bandwidths;
   bladerf_range range;
 
-  status = bladerf_get_bandwidth_range( _dev.get(), BLADERF_CHANNEL_RX(0),
-                                     &range );
-  if( status ) {
-    throw std::runtime_error( _pfx +
-                              "bladerf_get_bandwidth_range failed: " +
-                              bladerf_strerror(status) );
+  status = bladerf_get_bandwidth_range(_dev.get(), BLADERF_CHANNEL_RX(0),
+                                       &range);
+  if (status != 0) {
+    throw std::runtime_error(_pfx +
+                             "bladerf_get_bandwidth_range failed: " +
+                             bladerf_strerror(status));
   }
 
   bandwidths += osmosdr::range_t(range.min, range.max, range.step);
@@ -606,27 +620,28 @@ osmosdr::freq_range_t bladerf_common::filter_bandwidths()
   return bandwidths;
 }
 
-std::vector< std::string > bladerf_common::devices()
+std::vector < std::string > bladerf_common::devices()
 {
   struct bladerf_devinfo *devices;
   ssize_t n_devices;
-  std::vector< std::string > ret;
+  std::vector < std::string > ret;
 
-  n_devices = bladerf_get_device_list( &devices );
+  n_devices = bladerf_get_device_list(&devices);
 
-  if ( n_devices > 0 ) {
-    for ( ssize_t i = 0; i < n_devices; i++ ) {
+  if (n_devices > 0) {
+    for (ssize_t i = 0; i < n_devices; i++) {
       std::stringstream s;
       std::string serial(devices[i].serial);
 
-      s << "bladerf=" << devices[i].instance
-        << ",label='nuand bladeRF";
+      s << "bladerf=" << devices[i].instance << ",label='nuand bladeRF";
 
-      if ( serial.length() == 32 )
-        serial.replace( 4, 24, "..." );
+      if (serial.length() == 32) {
+        serial.replace(4, 24, "...");
+      }
 
-      if ( serial.length() )
+      if (serial.length()) {
         s << " SN " << serial;
+      }
 
       s << "'";
 
@@ -639,7 +654,7 @@ std::vector< std::string > bladerf_common::devices()
   return ret;
 }
 
-size_t bladerf_common::get_num_channels( bladerf_direction direction )
+size_t bladerf_common::get_num_channels(bladerf_direction direction)
 {
   // TODO: Need to figure out how to deal with output_signature()->max_streams
   // being stuck at 1 in source_impl.cc
@@ -652,8 +667,7 @@ size_t bladerf_common::get_num_channels( bladerf_direction direction )
   // return 1;
 }
 
-double bladerf_common::set_sample_rate( bladerf_direction direction,
-                                        double rate )
+double bladerf_common::set_sample_rate(bladerf_direction direction, double rate)
 {
   int status;
   struct bladerf_rational_rate rational_rate, actual;
@@ -662,97 +676,94 @@ double bladerf_common::set_sample_rate( bladerf_direction direction,
   rational_rate.den = 10000;
   rational_rate.num = (rate - rational_rate.integer) * rational_rate.den;
 
-  status = bladerf_set_rational_sample_rate( _dev.get(), direction,
-                                             &rational_rate, &actual );
-  if ( status ) {
-    throw std::runtime_error( _pfx +
-                              "Failed to set sample rate:" +
-                              bladerf_strerror(status));
+  status = bladerf_set_rational_sample_rate(_dev.get(), direction,
+                                            &rational_rate, &actual);
+  if (status != 0) {
+    throw std::runtime_error(_pfx + "Failed to set sample rate:" +
+                             bladerf_strerror(status));
   }
 
   return actual.integer + actual.num / static_cast<double>(actual.den);
 }
 
-double bladerf_common::get_sample_rate( bladerf_direction direction )
+double bladerf_common::get_sample_rate(bladerf_direction direction)
 {
   int status;
   struct bladerf_rational_rate rate;
 
-  status = bladerf_get_rational_sample_rate( _dev.get(), direction, &rate );
-  if ( status != 0 ) {
-    throw std::runtime_error( _pfx +
-                              "Failed to get sample rate:" +
-                              bladerf_strerror(status) );
+  status = bladerf_get_rational_sample_rate(_dev.get(), direction, &rate);
+  if (status != 0) {
+    throw std::runtime_error(_pfx + "Failed to get sample rate:" +
+                             bladerf_strerror(status));
   }
 
   return rate.integer + rate.num / static_cast<double>(rate.den);
 }
 
-osmosdr::freq_range_t bladerf_common::get_freq_range( size_t chan )
+osmosdr::freq_range_t bladerf_common::get_freq_range(size_t chan)
 {
-  return freq_range( static_cast<bladerf_channel>(chan) );
+  return freq_range(static_cast<bladerf_channel>(chan));
 }
 
-double bladerf_common::set_center_freq( double freq, size_t chan )
+double bladerf_common::set_center_freq(double freq, size_t chan)
 {
   int status;
 
   /* Check frequency range */
-  if( freq < get_freq_range( chan ).start() ||
-      freq > get_freq_range( chan ).stop() ) {
+  if (freq < get_freq_range(chan).start() ||
+      freq > get_freq_range(chan).stop()) {
     std::cerr << "Failed to set out of bound frequency: " << freq << std::endl;
   } else {
-    status = bladerf_set_frequency( _dev.get(),
-                                 static_cast<bladerf_channel>(chan),
-                                 static_cast<uint64_t>(freq) );
-    if( status ) {
-      throw std::runtime_error( _pfx +
-                                "failed to set center frequency " +
-                                boost::lexical_cast<std::string>(freq) + ": " +
-                                bladerf_strerror(status) );
+    status = bladerf_set_frequency(_dev.get(),
+                                   static_cast<bladerf_channel>(chan),
+                                   static_cast<uint64_t>(freq));
+    if (status != 0) {
+      throw std::runtime_error(_pfx +
+                               "failed to set center frequency " +
+                               boost::lexical_cast<std::string>(freq) + ": " +
+                               bladerf_strerror(status));
     }
   }
 
-  return get_center_freq( chan );
+  return get_center_freq(chan);
 }
 
-double bladerf_common::get_center_freq( size_t chan )
+double bladerf_common::get_center_freq(size_t chan)
 {
   int status;
   uint64_t freq;
 
-  status = bladerf_get_frequency( _dev.get(),
-                                  static_cast<bladerf_channel>(chan),
-                                  &freq );
-  if( status ) {
-    throw std::runtime_error( _pfx +
-                              "failed to get center frequency: " +
-                              bladerf_strerror(status) );
+  status = bladerf_get_frequency(_dev.get(),
+                                 static_cast<bladerf_channel>(chan),
+                                 &freq);
+  if (status != 0) {
+    throw std::runtime_error(_pfx + "failed to get center frequency: " +
+                             bladerf_strerror(status));
   }
 
   return static_cast<double>(freq);
 }
 
-std::vector<std::string> bladerf_common::get_gain_names( size_t chan )
+std::vector<std::string> bladerf_common::get_gain_names(size_t chan)
 {
   const size_t max_count = 16;
-  std::vector< std::string > names;
+  std::vector < std::string > names;
   char *gain_names[max_count];
   int status;
 
   names += SYSTEM_GAIN_NAME;
 
-  status = bladerf_get_gain_stages( _dev.get(),
-                                    static_cast<bladerf_channel>(chan),
-                                    (const char**)&gain_names,
-                                    max_count );
-  if(status < 0) {
-     throw std::runtime_error( _pfx +
-                              "failed to get gain stages: " +
-                              bladerf_strerror(status) );
+  status = bladerf_get_gain_stages(_dev.get(),
+                                   static_cast<bladerf_channel>(chan),
+                                   (const char **) &gain_names,
+                                   max_count);
+  if (status < 0) {
+    throw std::runtime_error(_pfx +
+                             "failed to get gain stages: " +
+                             bladerf_strerror(status));
   }
 
-  for( char **p = gain_names; *p != NULL && **p != '\0'; ++p ) {
+  for (char **p = gain_names; *p != NULL && **p != '\0'; ++p) {
     char *tmp = *p;
     names += std::string(tmp);
   };
@@ -760,100 +771,100 @@ std::vector<std::string> bladerf_common::get_gain_names( size_t chan )
   return names;
 }
 
-osmosdr::gain_range_t bladerf_common::get_gain_range( size_t chan )
+osmosdr::gain_range_t bladerf_common::get_gain_range(size_t chan)
 {
   /* This is an overall system gain range. */
-  return get_gain_range( SYSTEM_GAIN_NAME, chan );
+  return get_gain_range(SYSTEM_GAIN_NAME, chan);
 }
 
-osmosdr::gain_range_t bladerf_common::get_gain_range( const std::string & name,
-                                                      size_t chan )
+osmosdr::gain_range_t bladerf_common::get_gain_range(const std::string &name,
+                                                     size_t chan)
 {
   int status;
   struct bladerf_range range;
 
-  if( name == SYSTEM_GAIN_NAME ) {
-    status = bladerf_get_gain_range( _dev.get(),
-                                     static_cast<bladerf_channel>(chan),
-                                     &range );
+  if (name == SYSTEM_GAIN_NAME) {
+    status = bladerf_get_gain_range(_dev.get(),
+                                    static_cast<bladerf_channel>(chan),
+                                    &range);
   } else {
-    status = bladerf_get_gain_stage_range( _dev.get(),
-                                           static_cast<bladerf_channel>(chan),
-                                           name.c_str(), &range );
+    status = bladerf_get_gain_stage_range(_dev.get(),
+                                          static_cast<bladerf_channel>(chan),
+                                          name.c_str(),
+                                          &range);
   }
 
-  if( status ) {
-    throw std::runtime_error( _pfx +
-                              "bladerf_get_gain_range " + name + " failed: " +
-                              bladerf_strerror(status) );
+  if (status != 0) {
+    throw std::runtime_error(_pfx +
+                             "bladerf_get_gain_range " + name +
+                             " failed: " + bladerf_strerror(status));
   }
 
-  return osmosdr::gain_range_t( range.min, range.max, range.step );
+  return osmosdr::gain_range_t(range.min, range.max, range.step);
 }
 
-bool bladerf_common::set_gain_mode( bool automatic, size_t chan )
+bool bladerf_common::set_gain_mode(bool automatic, size_t chan)
 {
   int status;
   bladerf_gain_mode mode = automatic ? BLADERF_GAIN_DEFAULT : BLADERF_GAIN_MGC;
 
-  status = bladerf_set_gain_mode( _dev.get(),
-                                  static_cast<bladerf_channel>(chan),
-                                  mode );
+  status = bladerf_set_gain_mode(_dev.get(),
+                                 static_cast<bladerf_channel>(chan),
+                                 mode);
 
-  if( status ) {
-    throw std::runtime_error( _pfx +
-                              "bladerf_set_gain_mode " +
-                              (automatic ? "automatic" : "manual") +
-                              " failed: " +
-                              bladerf_strerror(status) );
+  if (status != 0) {
+    throw std::runtime_error(_pfx +
+                             "bladerf_set_gain_mode " +
+                             (automatic ? "automatic" : "manual") +
+                             " failed: " + bladerf_strerror(status));
   }
 
   return get_gain_mode(chan);
 }
 
-bool bladerf_common::get_gain_mode( size_t chan )
+bool bladerf_common::get_gain_mode(size_t chan)
 {
   int status;
   bladerf_gain_mode gainmode;
 
-  status = bladerf_get_gain_mode( _dev.get(),
-                                  static_cast<bladerf_channel>(chan),
-                                  &gainmode );
+  status = bladerf_get_gain_mode(_dev.get(),
+                                 static_cast<bladerf_channel>(chan),
+                                 &gainmode);
 
-  if( status ) {
-    throw std::runtime_error( _pfx +
-                              "bladerf_get_gain_mode failed: " +
-                              bladerf_strerror(status) );
+  if (status != 0) {
+    throw std::runtime_error(_pfx + "bladerf_get_gain_mode failed: " +
+                             bladerf_strerror(status));
   }
 
   return (gainmode != BLADERF_GAIN_MGC);
 }
 
-double bladerf_common::set_gain( double gain, size_t chan )
+double bladerf_common::set_gain(double gain, size_t chan)
 {
-  return set_gain( gain, SYSTEM_GAIN_NAME, chan );
+  return set_gain(gain, SYSTEM_GAIN_NAME, chan);
 }
 
-double bladerf_common::set_gain( double gain, const std::string & name, size_t chan )
+double bladerf_common::set_gain(double gain,
+                                const std::string &name, size_t chan)
 {
   int status;
 
-  if( name == SYSTEM_GAIN_NAME ) {
-    status = bladerf_set_gain( _dev.get(),
-                               static_cast<bladerf_channel>(chan),
-                               static_cast<int>(gain) );
+  if (name == SYSTEM_GAIN_NAME) {
+    status = bladerf_set_gain(_dev.get(),
+                              static_cast<bladerf_channel>(chan),
+                              static_cast<int>(gain));
   } else {
-    status = bladerf_set_gain_stage( _dev.get(),
-                                     static_cast<bladerf_channel>(chan),
-                                     name.c_str(),
-                                     static_cast<int>(gain) );
+    status = bladerf_set_gain_stage(_dev.get(),
+                                    static_cast<bladerf_channel>(chan),
+                                    name.c_str(),
+                                    static_cast<int>(gain));
   }
 
   /* Check for errors */
-  if( status ) {
+  if (status != 0) {
     std::string errmsg = _pfx + "could not set " + name + " gain: " +
                          bladerf_strerror(status);
-    if ( BLADERF_ERR_UNSUPPORTED == status ) {
+    if (BLADERF_ERR_UNSUPPORTED == status) {
       // unsupported, but not worth crashing out
       std::cerr << errmsg << std::endl;
     } else {
@@ -861,42 +872,42 @@ double bladerf_common::set_gain( double gain, const std::string & name, size_t c
     }
   }
 
-  return get_gain( name, chan );
+  return get_gain(name, chan);
 }
 
-double bladerf_common::get_gain( size_t chan )
+double bladerf_common::get_gain(size_t chan)
 {
-  return get_gain( SYSTEM_GAIN_NAME, chan );
+  return get_gain(SYSTEM_GAIN_NAME, chan);
 }
 
-double bladerf_common::get_gain( const std::string & name, size_t chan )
+double bladerf_common::get_gain(const std::string &name, size_t chan)
 {
   int status;
   int g;
 
-  if( name == SYSTEM_GAIN_NAME ) {
-    status = bladerf_get_gain( _dev.get(),
-                               static_cast<bladerf_channel>(chan),
-                               &g );
+  if (name == SYSTEM_GAIN_NAME) {
+    status = bladerf_get_gain(_dev.get(),
+                              static_cast<bladerf_channel>(chan),
+                              &g);
   } else {
-    status = bladerf_get_gain_stage( _dev.get(),
-                                     static_cast<bladerf_channel>(chan),
-                                     name.c_str(),
-                                     &g );
+    status = bladerf_get_gain_stage(_dev.get(),
+                                    static_cast<bladerf_channel>(chan),
+                                    name.c_str(),
+                                    &g);
   }
 
   /* Check for errors */
-  if( status ) {
-    throw std::runtime_error( _pfx + "could not get " + name + " gain: " +
-                              bladerf_strerror(status) );
+  if (status != 0) {
+    throw std::runtime_error(_pfx + "could not get " + name + " gain: " +
+                             bladerf_strerror(status));
   }
 
-  return (double)g;
+  return (double) g;
 }
 
-int bladerf_common::set_dc_offset( bladerf_direction direction,
-                                   const std::complex<double> &offset,
-                                   size_t chan )
+int bladerf_common::set_dc_offset(bladerf_direction direction,
+                                  const std::complex < double > &offset,
+                                  size_t chan)
 {
   int ret = 0;
   int16_t val_i, val_q;
@@ -904,65 +915,65 @@ int bladerf_common::set_dc_offset( bladerf_direction direction,
   val_i = static_cast<int16_t>(offset.real() * DCOFF_SCALE);
   val_q = static_cast<int16_t>(offset.imag() * DCOFF_SCALE);
 
-  ret  = bladerf_set_correction( _dev.get(), direction,
-                                 BLADERF_CORR_LMS_DCOFF_I, val_i );
-  ret |= bladerf_set_correction( _dev.get(), direction,
-                                 BLADERF_CORR_LMS_DCOFF_Q, val_q );
+  ret = bladerf_set_correction(_dev.get(), direction,
+                               BLADERF_CORR_LMS_DCOFF_I, val_i);
+  ret |= bladerf_set_correction(_dev.get(), direction,
+                                BLADERF_CORR_LMS_DCOFF_Q, val_q);
 
   return ret;
 }
 
-int bladerf_common::set_iq_balance( bladerf_direction direction,
-                                    const std::complex<double> &balance,
-                                    size_t chan )
+int bladerf_common::set_iq_balance(bladerf_direction direction,
+                                   const std::complex < double > &balance,
+                                   size_t chan)
 {
   int ret = 0;
   int16_t val_gain, val_phase;
 
-  val_gain  = static_cast<int16_t>(balance.real() * GAIN_SCALE);
+  val_gain = static_cast<int16_t>(balance.real() * GAIN_SCALE);
   val_phase = static_cast<int16_t>(balance.imag() * PHASE_SCALE);
 
-  ret  = bladerf_set_correction( _dev.get(), direction,
-                                 BLADERF_CORR_FPGA_GAIN, val_gain );
-  ret |= bladerf_set_correction( _dev.get(), direction,
-                                 BLADERF_CORR_FPGA_PHASE, val_phase );
+  ret = bladerf_set_correction(_dev.get(), direction,
+                               BLADERF_CORR_FPGA_GAIN, val_gain);
+  ret |= bladerf_set_correction(_dev.get(), direction,
+                                BLADERF_CORR_FPGA_PHASE, val_phase);
 
   return ret;
 }
 
-void bladerf_common::set_clock_source( const std::string &source,
-                                       const size_t mboard )
+void bladerf_common::set_clock_source(const std::string &source,
+                                      const size_t mboard)
 {
   int status;
   bladerf_vctcxo_tamer_mode tamer_mode;
-  std::vector<std::string> clock_sources;
+  std::vector < std::string > clock_sources;
   int index;
 
   tamer_mode = BLADERF_VCTCXO_TAMER_DISABLED;
   clock_sources = get_clock_sources(mboard);
   index = std::find(clock_sources.begin(), clock_sources.end(), source) - clock_sources.begin();
 
-  if ( index < static_cast<int>(clock_sources.size()) ) {
+  if (index < static_cast<int>(clock_sources.size())) {
     tamer_mode = static_cast<bladerf_vctcxo_tamer_mode>(index);
   }
 
-  status = bladerf_set_vctcxo_tamer_mode( _dev.get(), tamer_mode );
-  if ( status != 0 ) {
+  status = bladerf_set_vctcxo_tamer_mode(_dev.get(), tamer_mode);
+  if (status != 0) {
     throw std::runtime_error(_pfx + "Failed to set VCTCXO tamer mode: " +
                              bladerf_strerror(status));
   }
 }
 
-std::string bladerf_common::get_clock_source( const size_t mboard )
+std::string bladerf_common::get_clock_source(const size_t mboard)
 {
   int status;
   bladerf_vctcxo_tamer_mode tamer_mode;
-  std::vector<std::string> clock_sources;
+  std::vector < std::string > clock_sources;
 
   tamer_mode = BLADERF_VCTCXO_TAMER_INVALID;
 
-  status = bladerf_get_vctcxo_tamer_mode( _dev.get(), &tamer_mode );
-  if ( status != 0 ) {
+  status = bladerf_get_vctcxo_tamer_mode(_dev.get(), &tamer_mode);
+  if (status != 0) {
     throw std::runtime_error(_pfx + "Failed to get VCTCXO tamer mode: " +
                              bladerf_strerror(status));
   }
@@ -972,34 +983,35 @@ std::string bladerf_common::get_clock_source( const size_t mboard )
   return clock_sources.at(tamer_mode);
 }
 
-std::vector<std::string> bladerf_common::get_clock_sources( const size_t mboard )
+std::vector < std::string > bladerf_common::get_clock_sources(const size_t mboard)
 {
-  std::vector<std::string> sources;
+  std::vector < std::string > sources;
 
   // assumes zero-based 1:1 mapping
-  sources.push_back("internal");      // BLADERF_VCTCXO_TAMER_DISABLED
-  sources.push_back("external_1pps"); // BLADERF_VCTCXO_TAMER_1_PPS
-  sources.push_back("external");      // BLADERF_VCTCXO_TAMER_10_MHZ
+  sources.push_back("internal");        // BLADERF_VCTCXO_TAMER_DISABLED
+  sources.push_back("external_1pps");   // BLADERF_VCTCXO_TAMER_1_PPS
+  sources.push_back("external");        // BLADERF_VCTCXO_TAMER_10_MHZ
 
   return sources;
 }
 
-void bladerf_common::set_smb_frequency( double frequency )
+void bladerf_common::set_smb_frequency(double frequency)
 {
   int status;
   uint32_t actual_frequency;
   actual_frequency = frequency;
 
-  status = bladerf_set_smb_frequency( _dev.get(),
-                                      static_cast<uint32_t>(frequency),
-                                      &actual_frequency );
-  if ( status != 0 ) {
+  status = bladerf_set_smb_frequency(_dev.get(),
+                                     static_cast<uint32_t>(frequency),
+                                     &actual_frequency);
+  if (status != 0) {
     throw std::runtime_error(_pfx + "Failed to set SMB frequency: " +
                              bladerf_strerror(status));
   }
 
-  if ( static_cast<uint32_t>(frequency) != actual_frequency ) {
-    std::cerr << _pfx << "Wanted SMB frequency is " << frequency
+  if (static_cast<uint32_t>(frequency) != actual_frequency) {
+    std::cerr << _pfx
+              << "Wanted SMB frequency is " << frequency
               << ", actual is " << actual_frequency
               << std::endl;
   }
@@ -1010,10 +1022,11 @@ double bladerf_common::get_smb_frequency()
   int status;
   unsigned int actual_frequency;
 
-  status = bladerf_get_smb_frequency( _dev.get(), &actual_frequency );
-  if ( status != 0 )
+  status = bladerf_get_smb_frequency(_dev.get(), &actual_frequency);
+  if (status != 0) {
     throw std::runtime_error(_pfx + "Failed to get SMB frequency: " +
                              bladerf_strerror(status));
+  }
 
   return static_cast<double>(actual_frequency);
 }
diff --git a/lib/bladerf/bladerf_sink_c.cc b/lib/bladerf/bladerf_sink_c.cc
index 32e664e..5207eb1 100644
--- a/lib/bladerf/bladerf_sink_c.cc
+++ b/lib/bladerf/bladerf_sink_c.cc
@@ -45,9 +45,9 @@
 
 //#define DEBUG_BLADERF_SINK
 #ifdef DEBUG_BLADERF_SINK
-#   define DBG(input)  std::cerr << _pfx << input << std::endl
+#define DBG(input)  std::cerr << _pfx << input << std::endl
 #else
-#   define DBG(input)
+#define DBG(input)
 #endif
 
 using namespace boost::assign;
@@ -56,9 +56,9 @@ using namespace boost::assign;
  * Create a new instance of bladerf_sink_c and return
  * a boost shared_ptr.  This is effectively the public constructor.
  */
-bladerf_sink_c_sptr make_bladerf_sink_c (const std::string &args)
+bladerf_sink_c_sptr make_bladerf_sink_c(const std::string &args)
 {
-  return gnuradio::get_initial_sptr(new bladerf_sink_c (args));
+  return gnuradio::get_initial_sptr(new bladerf_sink_c(args));
 }
 
 /*
@@ -70,18 +70,18 @@ bladerf_sink_c_sptr make_bladerf_sink_c (const std::string &args)
  * are connected to this block.  In this case, we accept either
  * 1 or 2 inputs.
  */
-static const int MIN_IN = 1;   // mininum number of input streams
-static const int MAX_IN = 2;   // maximum number of input streams
-static const int MIN_OUT = 0;  // minimum number of output streams
-static const int MAX_OUT = 0;  // maximum number of output streams
+static const int MIN_IN = 1;    // mininum number of input streams
+static const int MAX_IN = 2;    // maximum number of input streams
+static const int MIN_OUT = 0;   // minimum number of output streams
+static const int MAX_OUT = 0;   // maximum number of output streams
 
 /*
  * The private constructor
  */
-bladerf_sink_c::bladerf_sink_c (const std::string &args)
-  : gr::sync_block ("bladerf_sink_c",
-                    gr::io_signature::make (MIN_IN, MAX_IN, sizeof (gr_complex)),
-                    gr::io_signature::make (MIN_OUT, MAX_OUT, sizeof (gr_complex)))
+bladerf_sink_c::bladerf_sink_c(const std::string &args)
+  :gr::sync_block("bladerf_sink_c",
+                  gr::io_signature::make(MIN_IN, MAX_IN, sizeof(gr_complex)),
+                  gr::io_signature::make(MIN_OUT, MAX_OUT, sizeof(gr_complex)))
 {
   dict_t dict = params_to_dict(args);
 
@@ -104,8 +104,8 @@ bool bladerf_sink_c::stop()
 
 int bladerf_sink_c::transmit_with_tags(int noutput_items)
 {
+  int status;
   int count = 0;
-  int status = 0;
 
   // For a long burst, we may be transmitting the burst contents over
   // multiple work calls, so we'll just be sending the entire buffer
@@ -114,7 +114,7 @@ int bladerf_sink_c::transmit_with_tags(int noutput_items)
   int end_idx = (noutput_items - 1);
 
   struct bladerf_metadata meta;
-  std::vector<gr::tag_t> tags;
+  std::vector < gr::tag_t > tags;
 
   int16_t zeros[8] = { 0 };
 
@@ -135,29 +135,30 @@ int bladerf_sink_c::transmit_with_tags(int noutput_items)
       DBG("TX'ing " << noutput_items << " samples in within a burst...");
 
       return bladerf_sync_tx(_dev.get(),
-                             static_cast<void *>(_conv_buf),
+                             static_cast < void *>(_conv_buf),
                              noutput_items, &meta, _stream_timeout_ms);
     } else {
-        std::cerr << _pfx << "Dropping " << noutput_items
-                  << " samples not in a burst." << std::endl;
+      std::cerr << _pfx
+                << "Dropping " << noutput_items << " samples not in a burst."
+                << std::endl;
     }
   }
 
-
-  BOOST_FOREACH( gr::tag_t tag, tags) {
+  BOOST_FOREACH(gr::tag_t tag, tags) {
 
     // Upon seeing an SOB tag, update our offset. We'll TX the start of the
     // burst when we see an EOB or at the end of this function - whichever
     // occurs first.
     if (pmt::symbol_to_string(tag.key) == "tx_sob") {
       if (_in_burst) {
-        std::cerr << ("Got SOB while already within a burst");
+        std::cerr << ("Got SOB while already within a burst") << std::endl;
         return BLADERF_ERR_INVAL;
       } else {
-        start_idx = static_cast<int>(tag.offset - nitems_read(0));
+        start_idx = static_cast < int >(tag.offset - nitems_read(0));
         DBG("Got SOB " << start_idx << " samples into work payload");
 
-        meta.flags |= (BLADERF_META_FLAG_TX_NOW | BLADERF_META_FLAG_TX_BURST_START);
+        meta.flags |=
+          (BLADERF_META_FLAG_TX_NOW | BLADERF_META_FLAG_TX_BURST_START);
         _in_burst = true;
 
       }
@@ -166,12 +167,11 @@ int bladerf_sink_c::transmit_with_tags(int noutput_items)
         std::cerr << _pfx << "Got EOB while not in burst" << std::endl;
         return BLADERF_ERR_INVAL;
       }
-
       // Upon seeing an EOB, transmit what we have and reset our state
-      end_idx = static_cast<int>(tag.offset - nitems_read(0));
+      end_idx = static_cast < int >(tag.offset - nitems_read(0));
       DBG("Got EOB " << end_idx << " samples into work payload");
 
-      if ( (start_idx == INVALID_IDX) || (start_idx > end_idx) ) {
+      if ((start_idx == INVALID_IDX) || (start_idx > end_idx)) {
         DBG("Buffer indicies are in an invalid state!");
         return BLADERF_ERR_INVAL;
       }
@@ -181,7 +181,7 @@ int bladerf_sink_c::transmit_with_tags(int noutput_items)
       DBG("TXing @ EOB [" << start_idx << ":" << end_idx << "]");
 
       status = bladerf_sync_tx(_dev.get(),
-                               static_cast<void *>(&_conv_buf[2*start_idx]),
+                               static_cast < void *>(&_conv_buf[2 * start_idx]),
                                count, &meta, _stream_timeout_ms);
       if (status != 0) {
         return status;
@@ -199,10 +199,9 @@ int bladerf_sink_c::transmit_with_tags(int noutput_items)
       meta.flags |= BLADERF_META_FLAG_TX_BURST_END;
 
       status = bladerf_sync_tx(_dev.get(),
-                               static_cast<void *>(zeros),
+                               static_cast < void *>(zeros),
                                4, &meta, _stream_timeout_ms);
 
-
       /* Reset our state */
       start_idx = INVALID_IDX;
       end_idx = (noutput_items - 1);
@@ -218,25 +217,25 @@ int bladerf_sink_c::transmit_with_tags(int noutput_items)
 
   // We had a start of burst with no end yet - transmit those samples
   if (_in_burst) {
-      count = end_idx - start_idx + 1;
+    count = end_idx - start_idx + 1;
 
-      DBG("TXing SOB [" << start_idx << ":" << end_idx << "]");
+    DBG("TXing SOB [" << start_idx << ":" << end_idx << "]");
 
-      status = bladerf_sync_tx(_dev.get(),
-                               static_cast<void *>(&_conv_buf[2*start_idx]),
-                               count, &meta, _stream_timeout_ms);
+    status = bladerf_sync_tx(_dev.get(),
+                             static_cast < void *>(&_conv_buf[2 * start_idx]),
+                             count, &meta, _stream_timeout_ms);
   }
 
   return status;
 }
 
-int bladerf_sink_c::work( int noutput_items,
-                          gr_vector_const_void_star &input_items,
-                          gr_vector_void_star &output_items )
+int bladerf_sink_c::work(int noutput_items,
+                         gr_vector_const_void_star &input_items,
+                         gr_vector_void_star &output_items)
 {
   const gr_complex *in = (const gr_complex *) input_items[0];
   const float scaling = 2000.0f;
-  int ret;
+  int status;
 
   if (noutput_items > _conv_buf_size) {
     void *tmp;
@@ -244,36 +243,37 @@ int bladerf_sink_c::work( int noutput_items,
     _conv_buf_size = noutput_items;
     tmp = realloc(_conv_buf, _conv_buf_size * 2 * sizeof(int16_t));
     if (tmp == NULL) {
-      throw std::runtime_error( std::string(__FUNCTION__) +
-                                "Failed to realloc _conv_buf" );
+      throw std::runtime_error(_pfx + "Failed to realloc _conv_buf");
     } else {
       DBG("Resized _conv_buf to " << _conv_buf_size << " samples");
     }
 
-    _conv_buf = static_cast<int16_t*>(tmp);
+    _conv_buf = static_cast < int16_t * >(tmp);
   }
 
   /* Convert floating point samples into fixed point */
-  volk_32f_s32f_convert_16i(_conv_buf, (float*)in, scaling, 2 * noutput_items);
+  volk_32f_s32f_convert_16i(_conv_buf, (float *) in, scaling,
+                            2 * noutput_items);
 
   if (_use_metadata) {
-    ret = transmit_with_tags(noutput_items);
+    status = transmit_with_tags(noutput_items);
   } else {
-    ret = bladerf_sync_tx(_dev.get(), static_cast<void *>(_conv_buf),
-                          noutput_items, NULL, _stream_timeout_ms);
+    status = bladerf_sync_tx(_dev.get(), static_cast < void *>(_conv_buf),
+                             noutput_items, NULL, _stream_timeout_ms);
   }
 
-  if ( ret != 0 ) {
-    std::cerr << _pfx << "bladerf_sync_tx error: "
-              << bladerf_strerror(ret) << std::endl;
+  if (status != 0) {
+    std::cerr << _pfx
+              << "bladerf_sync_tx error: " << bladerf_strerror(status)
+              << std::endl;
 
     _consecutive_failures++;
 
-    if ( _consecutive_failures >= MAX_CONSECUTIVE_FAILURES ) {
-        noutput_items = WORK_DONE;
-        std::cerr << _pfx
-                  << "Consecutive error limit hit. Shutting down."
-                  << std::endl;
+    if (_consecutive_failures >= MAX_CONSECUTIVE_FAILURES) {
+      noutput_items = WORK_DONE;
+      std::cerr << _pfx
+                << "Consecutive error limit hit. Shutting down."
+                << std::endl;
     }
   } else {
     _consecutive_failures = 0;
@@ -282,8 +282,7 @@ int bladerf_sink_c::work( int noutput_items,
   return noutput_items;
 }
 
-
-std::vector<std::string> bladerf_sink_c::get_devices()
+std::vector < std::string > bladerf_sink_c::get_devices()
 {
   return bladerf_common::devices();
 }
@@ -323,66 +322,68 @@ double bladerf_sink_c::get_center_freq(size_t chan)
   return bladerf_common::get_center_freq(BLADERF_CHANNEL_TX(chan));
 }
 
-double bladerf_sink_c::set_freq_corr( double ppm, size_t chan )
+double bladerf_sink_c::set_freq_corr(double ppm, size_t chan)
 {
   /* TODO: Write the VCTCXO with a correction value (also changes RX ppm value!) */
-  return get_freq_corr( BLADERF_CHANNEL_TX(chan) );
+  return get_freq_corr(BLADERF_CHANNEL_TX(chan));
 }
 
-double bladerf_sink_c::get_freq_corr( size_t chan )
+double bladerf_sink_c::get_freq_corr(size_t chan)
 {
   /* TODO: Return back the frequency correction in ppm */
   return 0;
 }
 
-std::vector<std::string> bladerf_sink_c::get_gain_names( size_t chan )
+std::vector < std::string > bladerf_sink_c::get_gain_names(size_t chan)
 {
   return bladerf_common::get_gain_names(BLADERF_CHANNEL_TX(chan));
 }
 
-osmosdr::gain_range_t bladerf_sink_c::get_gain_range( size_t chan )
+osmosdr::gain_range_t bladerf_sink_c::get_gain_range(size_t chan)
 {
   return bladerf_common::get_gain_range(BLADERF_CHANNEL_TX(chan));
 }
 
-osmosdr::gain_range_t bladerf_sink_c::get_gain_range( const std::string & name, size_t chan )
+osmosdr::gain_range_t bladerf_sink_c::get_gain_range(const std::string &name,
+                                                     size_t chan)
 {
   return bladerf_common::get_gain_range(name, BLADERF_CHANNEL_TX(chan));
 }
 
-bool bladerf_sink_c::set_gain_mode( bool automatic, size_t chan )
+bool bladerf_sink_c::set_gain_mode(bool automatic, size_t chan)
 {
   return bladerf_common::set_gain_mode(automatic, BLADERF_CHANNEL_TX(chan));
 }
 
-bool bladerf_sink_c::get_gain_mode( size_t chan )
+bool bladerf_sink_c::get_gain_mode(size_t chan)
 {
   return bladerf_common::get_gain_mode(BLADERF_CHANNEL_TX(chan));
 }
 
-double bladerf_sink_c::set_gain( double gain, size_t chan )
+double bladerf_sink_c::set_gain(double gain, size_t chan)
 {
   return bladerf_common::set_gain(gain, BLADERF_CHANNEL_TX(chan));
 }
 
-double bladerf_sink_c::set_gain( double gain, const std::string & name, size_t chan)
+double bladerf_sink_c::set_gain(double gain, const std::string &name,
+                                size_t chan)
 {
   return bladerf_common::set_gain(gain, name, BLADERF_CHANNEL_TX(chan));
 }
 
-double bladerf_sink_c::get_gain( size_t chan )
+double bladerf_sink_c::get_gain(size_t chan)
 {
   return bladerf_common::get_gain(BLADERF_CHANNEL_TX(chan));
 }
 
-double bladerf_sink_c::get_gain( const std::string & name, size_t chan )
+double bladerf_sink_c::get_gain(const std::string &name, size_t chan)
 {
   return bladerf_common::get_gain(name, BLADERF_CHANNEL_TX(chan));
 }
 
-std::vector< std::string > bladerf_sink_c::get_antennas( size_t chan )
+std::vector < std::string > bladerf_sink_c::get_antennas(size_t chan)
 {
-  std::vector< std::string > antennas;
+  std::vector < std::string > antennas;
 
   antennas += "TX0";
 
@@ -393,83 +394,87 @@ std::vector< std::string > bladerf_sink_c::get_antennas( size_t chan )
   return antennas;
 }
 
-std::string bladerf_sink_c::set_antenna( const std::string & antenna, size_t chan )
+std::string bladerf_sink_c::set_antenna(const std::string &antenna,
+                                        size_t chan)
 {
-  return get_antenna( BLADERF_CHANNEL_TX(chan) );
+  return get_antenna(BLADERF_CHANNEL_TX(chan));
 }
 
-std::string bladerf_sink_c::get_antenna( size_t chan )
+std::string bladerf_sink_c::get_antenna(size_t chan)
 {
   /* We only have a single transmit antenna here */
   // TODO: the above is a lie
   return "TX0";
 }
 
-void bladerf_sink_c::set_dc_offset( const std::complex<double> &offset, size_t chan )
+void bladerf_sink_c::set_dc_offset(const std::complex < double > &offset,
+                                   size_t chan)
 {
-  int ret = 0;
+  int status;
 
-  ret = bladerf_common::set_dc_offset(BLADERF_TX, offset, chan);
+  status = bladerf_common::set_dc_offset(BLADERF_TX, offset, chan);
 
-  if( ret ) {
-    throw std::runtime_error( std::string(__FUNCTION__) + " " +
-                              "could not set dc offset: " +
-                              std::string(bladerf_strerror(ret)) );
+  if (status != 0) {
+    throw std::runtime_error(_pfx + "could not set dc offset: " +
+                             bladerf_strerror(status));
   }
 }
 
-void bladerf_sink_c::set_iq_balance( const std::complex<double> &balance, size_t chan )
+void bladerf_sink_c::set_iq_balance(const std::complex < double > &balance,
+                                    size_t chan)
 {
-  int ret = 0;
+  int status;
 
-  ret = bladerf_common::set_iq_balance(BLADERF_TX, balance, chan);
+  status = bladerf_common::set_iq_balance(BLADERF_TX, balance, chan);
 
-  if( ret ) {
-    throw std::runtime_error( std::string(__FUNCTION__) + " " +
-                              "could not set iq balance: " +
-                              std::string(bladerf_strerror(ret)) );
+  if (status != 0) {
+    throw std::runtime_error(_pfx + "could not set iq balance: " +
+                             bladerf_strerror(status));
   }
 }
 
-double bladerf_sink_c::set_bandwidth( double bandwidth, size_t chan )
+double bladerf_sink_c::set_bandwidth(double bandwidth, size_t chan)
 {
-  int ret;
+  int status;
   uint32_t actual;
 
-  if ( bandwidth == 0.0 ) /* bandwidth of 0 means automatic filter selection */
-    bandwidth = get_sample_rate() * 0.75; /* select narrower filters to prevent aliasing */
+  if (bandwidth == 0.0) {
+    /* bandwidth of 0 means automatic filter selection */
+    /* select narrower filters to prevent aliasing */
+    bandwidth = get_sample_rate() * 0.75;
+  }
 
-  ret = bladerf_set_bandwidth( _dev.get(), BLADERF_TX, (uint32_t)bandwidth, &actual );
-  if( ret ) {
-    throw std::runtime_error( std::string(__FUNCTION__) + " " +
-                              "could not set bandwidth:" +
-                              std::string(bladerf_strerror(ret)) );
+  status = bladerf_set_bandwidth(_dev.get(), BLADERF_TX, (uint32_t) bandwidth,
+                                 &actual);
+  if (status != 0) {
+    throw std::runtime_error(_pfx + "could not set bandwidth:" +
+                             bladerf_strerror(status));
   }
 
   return get_bandwidth();
 }
 
-double bladerf_sink_c::get_bandwidth( size_t chan )
+double bladerf_sink_c::get_bandwidth(size_t chan)
 {
+  int status;
   uint32_t bandwidth;
-  int ret;
 
-  ret = bladerf_get_bandwidth( _dev.get(), BLADERF_TX, &bandwidth );
-  if( ret ) {
-    throw std::runtime_error( std::string(__FUNCTION__) + " " +
-                              "could not get bandwidth: " +
-                              std::string(bladerf_strerror(ret)) );
+  status = bladerf_get_bandwidth(_dev.get(), BLADERF_TX, &bandwidth);
+  if (status != 0) {
+    throw std::runtime_error(_pfx + "could not get bandwidth: " +
+                             bladerf_strerror(status));
   }
 
-  return (double)bandwidth;
+  return (double) bandwidth;
 }
 
-osmosdr::freq_range_t bladerf_sink_c::get_bandwidth_range( size_t chan )
+osmosdr::freq_range_t bladerf_sink_c::get_bandwidth_range(size_t chan)
 {
   return filter_bandwidths();
 }
 
-void bladerf_sink_c::set_clock_source(const std::string &source, const size_t mboard)
+void bladerf_sink_c::set_clock_source(const std::string &source,
+                                      const size_t mboard)
 {
   bladerf_common::set_clock_source(source, mboard);
 }
@@ -479,7 +484,7 @@ std::string bladerf_sink_c::get_clock_source(const size_t mboard)
   return bladerf_common::get_clock_source(mboard);
 }
 
-std::vector<std::string> bladerf_sink_c::get_clock_sources(const size_t mboard)
+std::vector < std::string > bladerf_sink_c::get_clock_sources(const size_t mboard)
 {
   return bladerf_common::get_clock_sources(mboard);
 }
diff --git a/lib/bladerf/bladerf_source_c.cc b/lib/bladerf/bladerf_source_c.cc
index fc15c50..81a34f0 100644
--- a/lib/bladerf/bladerf_source_c.cc
+++ b/lib/bladerf/bladerf_source_c.cc
@@ -48,9 +48,9 @@ using namespace boost::assign;
  * Create a new instance of bladerf_source_c and return
  * a boost shared_ptr.  This is effectively the public constructor.
  */
-bladerf_source_c_sptr make_bladerf_source_c (const std::string &args)
+bladerf_source_c_sptr make_bladerf_source_c(const std::string &args)
 {
-  return gnuradio::get_initial_sptr(new bladerf_source_c (args));
+  return gnuradio::get_initial_sptr(new bladerf_source_c(args));
 }
 
 /*
@@ -62,20 +62,20 @@ bladerf_source_c_sptr make_bladerf_source_c (const std::string &args)
  * are connected to this block.  In this case, we accept either
  * 1 or 2 outputs.
  */
-static const int MIN_IN = 0;	// mininum number of input streams
-static const int MAX_IN = 0;	// maximum number of input streams
-static const int MIN_OUT = 1;	// minimum number of output streams
-static const int MAX_OUT = 2;	// maximum number of output streams
+static const int MIN_IN = 0;    // mininum number of input streams
+static const int MAX_IN = 0;    // maximum number of input streams
+static const int MIN_OUT = 1;   // minimum number of output streams
+static const int MAX_OUT = 2;   // maximum number of output streams
 
 /*
  * The private constructor
  */
-bladerf_source_c::bladerf_source_c (const std::string &args)
-  : gr::sync_block ("bladerf_source_c",
-                    gr::io_signature::make (MIN_IN, MAX_IN, sizeof (gr_complex)),
-                    gr::io_signature::make (MIN_OUT, MAX_OUT, sizeof (gr_complex)))
+bladerf_source_c::bladerf_source_c(const std::string &args)
+  :gr::sync_block("bladerf_source_c",
+                  gr::io_signature::make(MIN_IN, MAX_IN, sizeof(gr_complex)),
+                  gr::io_signature::make(MIN_OUT, MAX_OUT, sizeof(gr_complex)))
 {
-  int ret;
+  int status;
   std::string device_name;
   struct bladerf_version fpga_version;
 
@@ -83,36 +83,46 @@ bladerf_source_c::bladerf_source_c (const std::string &args)
 
   init(dict, BLADERF_RX);
 
-  if (dict.count("sampling"))
-  {
+  if (dict.count("sampling")) {
     std::string sampling = dict["sampling"];
 
-    std::cerr << _pfx << "Setting bladerf sampling to " << sampling << std::endl;
-    if( sampling == "internal") {
-      ret = bladerf_set_sampling( _dev.get(), BLADERF_SAMPLING_INTERNAL );
-      if ( ret != 0 )
-        std::cerr << _pfx << "Problem while setting sampling mode:"
-                  << bladerf_strerror(ret) << std::endl;
-    } else if( sampling == "external" ) {
-      ret = bladerf_set_sampling( _dev.get(), BLADERF_SAMPLING_EXTERNAL );
-      if ( ret != 0 )
-        std::cerr << _pfx << "Problem while setting sampling mode:"
-                  << bladerf_strerror(ret) << std::endl;
+    std::cerr << _pfx
+              << "Setting bladerf sampling to " << sampling
+              << std::endl;
+
+    if (sampling == "internal") {
+      status = bladerf_set_sampling(_dev.get(), BLADERF_SAMPLING_INTERNAL);
+      if (status != 0) {
+        std::cerr << _pfx
+                  << "Problem while setting sampling mode: "
+                  << bladerf_strerror(status)
+                  << std::endl;
+      }
+
+    } else if (sampling == "external") {
+      status = bladerf_set_sampling(_dev.get(), BLADERF_SAMPLING_EXTERNAL);
+      if (status != 0) {
+        std::cerr << _pfx
+                  << "Problem while setting sampling mode: "
+                  << bladerf_strerror(status)
+                  << std::endl;
+      }
+
     } else {
-        std::cerr << _pfx << "Invalid sampling mode " << sampling << std::endl;
+      std::cerr << _pfx << "Invalid sampling mode " << sampling << std::endl;
     }
   }
 
   /* Warn user about using an old FPGA version, as we no longer strip off the
    * markers that were pressent in the pre-v0.0.1 FPGA */
-  if (bladerf_fpga_version( _dev.get(), &fpga_version ) != 0) {
+  if (bladerf_fpga_version(_dev.get(), &fpga_version) != 0) {
     std::cerr << _pfx << "Failed to get FPGA version" << std::endl;
-  } else if ( fpga_version.major <= 0 &&
-              fpga_version.minor <= 0 &&
-              fpga_version.patch < 1 ) {
+  } else if (fpga_version.major <= 0 &&
+             fpga_version.minor <= 0 && fpga_version.patch < 1) {
 
-    std::cerr << _pfx << "Warning: FPGA version v0.0.1 or later is required. "
-              << "Using an earlier FPGA version will result in misinterpeted samples. "
+    std::cerr << _pfx
+              << "Warning: FPGA version v0.0.1 or later is required. Using an "
+              << "earlier FPGA version will result in misinterpeted samples."
               << std::endl;
   }
 }
@@ -127,12 +137,12 @@ bool bladerf_source_c::stop()
   return bladerf_common::stop(BLADERF_RX);
 }
 
-int bladerf_source_c::work( int noutput_items,
-                            gr_vector_const_void_star &input_items,
-                            gr_vector_void_star &output_items )
+int bladerf_source_c::work(int noutput_items,
+                           gr_vector_const_void_star &input_items,
+                           gr_vector_void_star &output_items)
 {
-  int ret;
   const float scaling = 2048.0f;
+  int status;
   gr_complex *out = static_cast<gr_complex *>(output_items[0]);
   struct bladerf_metadata meta;
   struct bladerf_metadata *meta_ptr = NULL;
@@ -143,11 +153,10 @@ int bladerf_source_c::work( int noutput_items,
     _conv_buf_size = noutput_items;
     tmp = realloc(_conv_buf, _conv_buf_size * 2 * sizeof(int16_t));
     if (tmp == NULL) {
-      throw std::runtime_error( std::string(__FUNCTION__) +
-                                "Failed to realloc _conv_buf" );
+      throw std::runtime_error(_pfx + "Failed to realloc _conv_buf");
     }
 
-    _conv_buf = static_cast<int16_t*>(tmp);
+    _conv_buf = static_cast<int16_t *>(tmp);
   }
 
   if (_use_metadata) {
@@ -157,31 +166,33 @@ int bladerf_source_c::work( int noutput_items,
   }
 
   /* Grab all the samples into the temporary buffer */
-  ret = bladerf_sync_rx(_dev.get(), static_cast<void *>(_conv_buf),
-                        noutput_items, meta_ptr, _stream_timeout_ms);
-  if ( ret != 0 ) {
-    std::cerr << _pfx << "bladerf_sync_rx error: "
-              << bladerf_strerror(ret) << std::endl;
+  status = bladerf_sync_rx(_dev.get(), static_cast<void *>(_conv_buf),
+                           noutput_items, meta_ptr, _stream_timeout_ms);
+  if (status != 0) {
+    std::cerr << _pfx
+              << "bladerf_sync_rx error: " << bladerf_strerror(status)
+              << std::endl;
 
     _consecutive_failures++;
 
-    if ( _consecutive_failures >= MAX_CONSECUTIVE_FAILURES ) {
-        std::cerr << _pfx
-                  << "Consecutive error limit hit. Shutting down."
-                  << std::endl;
-        return WORK_DONE;
+    if (_consecutive_failures >= MAX_CONSECUTIVE_FAILURES) {
+      std::cerr << _pfx
+                << "Consecutive error limit hit. Shutting down."
+                << std::endl;
+      return WORK_DONE;
     }
   } else {
-      _consecutive_failures = 0;
+    _consecutive_failures = 0;
   }
 
   /* Convert them from fixed to floating point */
-  volk_16i_s32f_convert_32f((float*)out, _conv_buf, scaling, 2*noutput_items);
+  volk_16i_s32f_convert_32f((float *) out, _conv_buf, scaling,
+                            2 * noutput_items);
 
   return noutput_items;
 }
 
-std::vector<std::string> bladerf_source_c::get_devices()
+std::vector < std::string > bladerf_source_c::get_devices()
 {
   return bladerf_common::devices();
 }
@@ -196,14 +207,14 @@ osmosdr::meta_range_t bladerf_source_c::get_sample_rates()
   return sample_rates();
 }
 
-double bladerf_source_c::set_sample_rate( double rate )
+double bladerf_source_c::set_sample_rate(double rate)
 {
-  return bladerf_common::set_sample_rate( BLADERF_RX, rate);
+  return bladerf_common::set_sample_rate(BLADERF_RX, rate);
 }
 
 double bladerf_source_c::get_sample_rate()
 {
-  return bladerf_common::get_sample_rate( BLADERF_RX );
+  return bladerf_common::get_sample_rate(BLADERF_RX);
 }
 
 osmosdr::freq_range_t bladerf_source_c::get_freq_range(size_t chan)
@@ -221,66 +232,68 @@ double bladerf_source_c::get_center_freq(size_t chan)
   return bladerf_common::get_center_freq(BLADERF_CHANNEL_RX(chan));
 }
 
-double bladerf_source_c::set_freq_corr( double ppm, size_t chan )
+double bladerf_source_c::set_freq_corr(double ppm, size_t chan)
 {
   /* TODO: Write the VCTCXO with a correction value (also changes TX ppm value!) */
-  return get_freq_corr( BLADERF_CHANNEL_RX(chan) );
+  return get_freq_corr(BLADERF_CHANNEL_RX(chan));
 }
 
-double bladerf_source_c::get_freq_corr( size_t chan )
+double bladerf_source_c::get_freq_corr(size_t chan)
 {
   /* TODO: Return back the frequency correction in ppm */
   return 0;
 }
 
-std::vector<std::string> bladerf_source_c::get_gain_names( size_t chan )
+std::vector < std::string > bladerf_source_c::get_gain_names(size_t chan)
 {
   return bladerf_common::get_gain_names(BLADERF_CHANNEL_RX(chan));
 }
 
-osmosdr::gain_range_t bladerf_source_c::get_gain_range( size_t chan )
+osmosdr::gain_range_t bladerf_source_c::get_gain_range(size_t chan)
 {
   return bladerf_common::get_gain_range(BLADERF_CHANNEL_RX(chan));
 }
 
-osmosdr::gain_range_t bladerf_source_c::get_gain_range( const std::string & name, size_t chan )
+osmosdr::gain_range_t bladerf_source_c::get_gain_range(const std::string &name,
+                                                       size_t chan)
 {
   return bladerf_common::get_gain_range(name, BLADERF_CHANNEL_RX(chan));
 }
 
-bool bladerf_source_c::set_gain_mode( bool automatic, size_t chan )
+bool bladerf_source_c::set_gain_mode(bool automatic, size_t chan)
 {
   return bladerf_common::set_gain_mode(automatic, BLADERF_CHANNEL_RX(chan));
 }
 
-bool bladerf_source_c::get_gain_mode( size_t chan )
+bool bladerf_source_c::get_gain_mode(size_t chan)
 {
   return bladerf_common::get_gain_mode(BLADERF_CHANNEL_RX(chan));
 }
 
-double bladerf_source_c::set_gain( double gain, size_t chan )
+double bladerf_source_c::set_gain(double gain, size_t chan)
 {
   return bladerf_common::set_gain(gain, BLADERF_CHANNEL_RX(chan));
 }
 
-double bladerf_source_c::set_gain( double gain, const std::string & name, size_t chan)
+double bladerf_source_c::set_gain(double gain, const std::string &name,
+                                  size_t chan)
 {
   return bladerf_common::set_gain(gain, name, BLADERF_CHANNEL_RX(chan));
 }
 
-double bladerf_source_c::get_gain( size_t chan )
+double bladerf_source_c::get_gain(size_t chan)
 {
   return bladerf_common::get_gain(BLADERF_CHANNEL_RX(chan));
 }
 
-double bladerf_source_c::get_gain( const std::string & name, size_t chan )
+double bladerf_source_c::get_gain(const std::string &name, size_t chan)
 {
   return bladerf_common::get_gain(name, BLADERF_CHANNEL_RX(chan));
 }
 
-std::vector< std::string > bladerf_source_c::get_antennas( size_t chan )
+std::vector < std::string > bladerf_source_c::get_antennas(size_t chan)
 {
-  std::vector< std::string > antennas;
+  std::vector < std::string > antennas;
 
   antennas += "RX0";
 
@@ -291,109 +304,121 @@ std::vector< std::string > bladerf_source_c::get_antennas( size_t chan )
   return antennas;
 }
 
-std::string bladerf_source_c::set_antenna( const std::string & antenna, size_t chan )
+std::string bladerf_source_c::set_antenna(const std::string &antenna,
+                                          size_t chan)
 {
-  return get_antenna( BLADERF_CHANNEL_RX(chan) );
+  return get_antenna(BLADERF_CHANNEL_RX(chan));
 }
 
-std::string bladerf_source_c::get_antenna( size_t chan )
+std::string bladerf_source_c::get_antenna(size_t chan)
 {
   /* We only have a single receive antenna here */
   // TODO: this is a lie
   return "RX0";
 }
 
-void bladerf_source_c::set_dc_offset_mode( int mode, size_t chan )
+void bladerf_source_c::set_dc_offset_mode(int mode, size_t chan)
 {
-  if ( osmosdr::source::DCOffsetOff == mode ) {
+  if (osmosdr::source::DCOffsetOff == mode) {
+    //_src->set_auto_dc_offset( false, chan );
+    /* reset to default for off-state */
+    set_dc_offset(std::complex < double >(0.0, 0.0), chan);
+  } else if (osmosdr::source::DCOffsetManual == mode) {
+    /* disable auto mode, but keep correcting with last known values */
     //_src->set_auto_dc_offset( false, chan );
-    set_dc_offset( std::complex<double>(0.0, 0.0), chan ); /* reset to default for off-state */
-  } else if ( osmosdr::source::DCOffsetManual == mode ) {
-    //_src->set_auto_dc_offset( false, chan ); /* disable auto mode, but keep correcting with last known values */
-  } else if ( osmosdr::source::DCOffsetAutomatic == mode ) {
+  } else if (osmosdr::source::DCOffsetAutomatic == mode) {
     //_src->set_auto_dc_offset( true, chan );
-    std::cerr << "Automatic DC correction mode is not implemented." << std::endl;
+    std::cerr << _pfx
+              << "Automatic DC correction mode is not implemented."
+              << std::endl;
   }
 }
 
-void bladerf_source_c::set_dc_offset( const std::complex<double> &offset, size_t chan )
+void bladerf_source_c::set_dc_offset(const std::complex < double > &offset,
+                                     size_t chan)
 {
-  int ret = 0;
+  int status;
 
-  ret = bladerf_common::set_dc_offset(BLADERF_RX, offset, chan);
+  status = bladerf_common::set_dc_offset(BLADERF_RX, offset, chan);
 
-  if( ret ) {
-    throw std::runtime_error( std::string(__FUNCTION__) + " " +
-                              "could not set dc offset: " +
-                              std::string(bladerf_strerror(ret)) );
+  if (status != 0) {
+    throw std::runtime_error(_pfx + "could not set dc offset: " +
+                             bladerf_strerror(status));
   }
 }
 
-void bladerf_source_c::set_iq_balance_mode( int mode, size_t chan )
+void bladerf_source_c::set_iq_balance_mode(int mode, size_t chan)
 {
-  if ( osmosdr::source::IQBalanceOff == mode ) {
+  if (osmosdr::source::IQBalanceOff == mode) {
+    //_src->set_auto_iq_balance( false, chan );
+    /* reset to default for off-state */
+    set_iq_balance(std::complex < double >(0.0, 0.0), chan);
+  } else if (osmosdr::source::IQBalanceManual == mode) {
+    /* disable auto mode, but keep correcting with last known values */
     //_src->set_auto_iq_balance( false, chan );
-    set_iq_balance( std::complex<double>(0.0, 0.0), chan ); /* reset to default for off-state */
-  } else if ( osmosdr::source::IQBalanceManual == mode ) {
-    //_src->set_auto_iq_balance( false, chan ); /* disable auto mode, but keep correcting with last known values */
-  } else if ( osmosdr::source::IQBalanceAutomatic == mode ) {
+  } else if (osmosdr::source::IQBalanceAutomatic == mode) {
     //_src->set_auto_iq_balance( true, chan );
-    std::cerr << "Automatic IQ correction mode is not implemented." << std::endl;
+    std::cerr << _pfx
+              << "Automatic IQ correction mode is not implemented."
+              << std::endl;
   }
 }
 
-void bladerf_source_c::set_iq_balance( const std::complex<double> &balance, size_t chan )
+void bladerf_source_c::set_iq_balance(const std::complex < double > &balance,
+                                      size_t chan)
 {
-  int ret = 0;
+  int status;
 
-  ret = bladerf_common::set_iq_balance(BLADERF_RX, balance, chan);
+  status = bladerf_common::set_iq_balance(BLADERF_RX, balance, chan);
 
-  if( ret ) {
-    throw std::runtime_error( std::string(__FUNCTION__) + " " +
-                              "could not set iq balance: " +
-                              std::string(bladerf_strerror(ret)) );
+  if (status != 0) {
+    throw std::runtime_error(_pfx + "could not set iq balance: " +
+                             bladerf_strerror(status));
   }
 }
 
-double bladerf_source_c::set_bandwidth( double bandwidth, size_t chan )
+double bladerf_source_c::set_bandwidth(double bandwidth, size_t chan)
 {
-  int ret;
+  int status;
   uint32_t actual;
 
-  if ( bandwidth == 0.0 ) /* bandwidth of 0 means automatic filter selection */
-    bandwidth = get_sample_rate() * 0.75; /* select narrower filters to prevent aliasing */
+  if (bandwidth == 0.0) {
+    /* bandwidth of 0 means automatic filter selection */
+    /* select narrower filters to prevent aliasing */
+    bandwidth = get_sample_rate() * 0.75;
+  }
 
-  ret = bladerf_set_bandwidth( _dev.get(), BLADERF_RX, (uint32_t)bandwidth, &actual );
-  if( ret ) {
-    throw std::runtime_error( std::string(__FUNCTION__) + " " +
-                              "could not set bandwidth: " +
-                              std::string(bladerf_strerror(ret)) );
+  status = bladerf_set_bandwidth(_dev.get(), BLADERF_RX, (uint32_t) bandwidth,
+                                 &actual);
+  if (status != 0) {
+    throw std::runtime_error(_pfx + "could not set bandwidth: " +
+                             bladerf_strerror(status));
   }
 
   return get_bandwidth();
 }
 
-double bladerf_source_c::get_bandwidth( size_t chan )
+double bladerf_source_c::get_bandwidth(size_t chan)
 {
+  int status;
   uint32_t bandwidth;
-  int ret;
 
-  ret = bladerf_get_bandwidth( _dev.get(), BLADERF_RX, &bandwidth );
-  if( ret ) {
-    throw std::runtime_error( std::string(__FUNCTION__) + " " +
-                              "could not get bandwidth:" +
-                              std::string(bladerf_strerror(ret)) );
+  status = bladerf_get_bandwidth(_dev.get(), BLADERF_RX, &bandwidth);
+  if (status != 0) {
+    throw std::runtime_error(_pfx + "could not get bandwidth: " +
+                             bladerf_strerror(status));
   }
 
-  return (double)bandwidth;
+  return (double) bandwidth;
 }
 
-osmosdr::freq_range_t bladerf_source_c::get_bandwidth_range( size_t chan )
+osmosdr::freq_range_t bladerf_source_c::get_bandwidth_range(size_t chan)
 {
   return filter_bandwidths();
 }
 
-void bladerf_source_c::set_clock_source(const std::string &source, const size_t mboard)
+void bladerf_source_c::set_clock_source(const std::string &source,
+                                        const size_t mboard)
 {
   bladerf_common::set_clock_source(source, mboard);
 }
@@ -403,7 +428,7 @@ std::string bladerf_source_c::get_clock_source(const size_t mboard)
   return bladerf_common::get_clock_source(mboard);
 }
 
-std::vector<std::string> bladerf_source_c::get_clock_sources(const size_t mboard)
+std::vector < std::string > bladerf_source_c::get_clock_sources(const size_t mboard)
 {
   return bladerf_common::get_clock_sources(mboard);
 }
-- 
2.20.1

